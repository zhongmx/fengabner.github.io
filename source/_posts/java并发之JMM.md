---
title: java并发之JMM
date: 2020-07-07 23:45:25
categories: java 并发
tags:
	- java
	- 并发
---

# 区别Java内存结构与Java内存模型

概述：这两个概念比较容易混淆。JVM 内存结构和 Java 虚拟机的运行时区域有关，Java 内存模型（JMM）和 Java 的并发编程有关。

<!--more-->

## Java 内存结构

### 程序计数器

​		较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器。线程私有的内存区域。唯一一个区域没有任何OutOfMemoryError的区域。

​		线程执行的是一个Java方法，则计数器指示需要执行的字节码指令地址；如果执行的是Native方法，这个计数器的值为空。这个内存区域是唯一一个在Java规范中没有规定任何OutOfMemoryError情况的区域。

### 虚拟机栈

​		栈帧是方法运行期的基础数据结构栈容量可由-Xss参数设定。

​		线程私有，生命周期与线程相同。描述的是java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧，存储了局部变量表、操作数栈、动态链接、方法出口等信息。一个方法的调用直至执行完，就相当于是一个栈帧在虚拟机中入栈到出栈。
​		局部变量表：存放了编译期可知的各种基本数据类型、对象引用和returnAddress类型。局部变量表所需的内存空间在编译期间完成分配。

​		有可能抛出两个异常

		+ StackOverFlowError  如果线程请求的栈深度大于虚拟机所允许的深度
		+ OutOfMemoryError  如果虚拟机栈可以动态扩展，扩展时无法申请到足够内存

### 本地方法栈

​		本地方法栈与虚拟机栈所发挥的作用非常相似，只不过JVM Stacks是为虚拟机执行Java方法（字节码）服务的，而本地方法栈则是为JVM使用Native方法服务的。甚至有的虚拟机（Sun hotspot虚拟机）直接把本地方法栈和虚拟机栈合二为一，虚拟机栈一样，也会抛出StackOverFlowError和OutOfMemoryError异常。

### Java 堆

​		可通过参数 -Xms 和-Xmx设置。

​		线程共享，虚拟机启动时创建，唯一目的就是存放对象实例，从内存回收的角度。

​		细分为新生代（Eden空间、From Survivor、To Survivor），老年代。java堆可以处于物理上不连续的空间。如果堆中没有内存完成实例分配，并且堆也无法扩展，将抛出 OutOfMemoryError。

### 方法区

​		可以通过-XX:PermSize和-XX:MaxPermSize设置[^ 1]。

​		线程共享，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。java虚拟机规范也把方法区作为堆的一个逻辑部分。垃圾收集行为在这个内存区域是较少出现的，这个区域内存回收的目的主要是针对常量池的回收和对类型的卸载。当方法区无法满足内存分配需求时抛 OutOfMemoryError。

> #### 运行时常量池
>
> 方法区的一部分，用于存放编译器生成的各种字面量和符号引用。这部分内容将在类加载后进入方法区的运行时常量池中存放。运行期间也可能将新的常量放入池中。如String的intern()方法。

# Java 内存模型（JMM是什么?）

## 概述

Java 内存模型（Java Memory Model  JMM  ）是一组规范。来屏蔽掉各种硬件和操作系统的内存访问差异， 以实现让Java程序在各种平台下都能达到一致的内存访问效果。  

JMM 与处理器、缓存、并发、编译器有关。它解决了 CPU 多级缓存、处理器优化、指令重排等导致的结果不可预期的问题。

## 内存划分

JMM规定了内存主要划分为**主内存**和**工作内存**两种。此处的主内存和工作内存跟JVM内存划分（堆、栈、方法区）是在不同的层次上进行的，如果非要对应起来，主内存对应的是Java堆中的对象实例部分，工作内存对应的是栈中的部分区域，从更底层的来说，主内存对应的是硬件的物理内存，工作内存对应的是寄存器和高速缓存。

Java 内存模型中规定了所有的变量都存储在主内存中（类比物理硬件的主内存），每个线程还有自己的工作内存（类比高速缓存），线程的工作内存中保存了被该线程使用到主内存中的变量拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成。

[图片来源于网络](https://s0.lgstatic.com/i/image3/M01/00/EF/Ciqah154fUGAS19LAAGap07f1AU762.png)

![jmm](jmm.png)

## 内存间交互操作

java内存模型中定义了一套规范，8种操作，虚拟机实现必须保证每一个操作都是原子的，不可在分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许例外）

- lock   （锁定）：作用于主内存的变量，把一个变量标识为线程独占状态
- unlock （解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
- read  （读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用
- load   （载入）：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中
- use   （使用）：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令
- assign （赋值）：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中
- store  （存储）：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用
- write 　（写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中

如果要把一个变量从主内存中复制到工作内存，就需要按顺序地执行 read 和 load 操作，如果把变量从工作内存同步回主内存中，就要按顺序地执行 store 和 write 操作。Java 内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。也就是 read 和 load 之间，store 和 write 之间是可以插入其他指令的，如对主内存中的变量 a、b 进行访问时，可能的顺序是 read a，read b，load b， load a。Java 内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：

- 不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write
- 不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存
- 不允许一个线程将没有assign的数据从工作内存同步回主内存
- 一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作
- 一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁
- 如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值
- 如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量
- 对一个变量进行unlock操作之前，必须把此变量同步回主内存

# 三要素

Java内存模型是围绕着并发编程中原子性、可见性、有序性这三个特征来建立的。这也是Java解决多线程并行机制的环境下，制定出的一种规则，能够保证多个线程间可以有效地、正确地协同工作。

## 原子性

**原子性**是指一个操作是不可中断的，要么全部执行完毕，要么不执行。

基本类型数据的访问大都是原子操作，long 和double类型的变量是64位，但是在32位JVM中，32位的JVM会将64位数据的读写操作分为2次32位的读写操作来进行，这就导致了long、double类型的变量在32位虚拟机中是非原子操作，数据有可能会被破坏，也就意味着多个线程在并发访问的时候是线程非安全的。

## 可见性

可见性是指当一个线程修改了共享变量的值， 其他线程能够立即得知这个修改 。

比如

**synchronized** 当线程获取锁时会从主内存中获取共享变量的最新值，释放锁的时候会将共享变量同步到主内存中。

**volatile**也具备可见性，volatile的特殊规则保证了volatile变量值修改后的新值立刻同步到主内存，每次使用volatile变量前立即从主内存中刷新，因此volatile保证了多线程之间的操作变量的可见性。

除此之外，**Lock、final 都可以保证变量的可见性。**

## 有序性

Java内存模型中，允许编译器和处理器对指令进行**重排序**，但是**重排序**的过程不会影响单线程的执行结果，却会影响到多线程并发执行的正确性。

题外话：为什么要重排序？

“**重排序是对内存访问操作的一种优化，他可以在不影响单线程程序正确性的前提下进行一定的调整，进而提高程序的性能**。**但是对于多线程场景下，就可能产生一定的问题**”

**有序性的意思就是说 Java 内存模型中的指令重排不会影响单线程的执行顺序，但是会影响多线程并发执行的正确性，**所以在并发中我们必须要想办法保证并发代码的有序性。

volatile， synchronized，Lock，可以保证有序性。

# happens-before 原则

通过对Java内存模型的了解，JMM**目的是保证并发场景中的原子性、可见性和有序性。JMM处理并发问题主要采用两种方式：限制处理器优化和使用内存屏障。**在并发编程当中为了保证数据的安全，必须满足原子性、可见性和有序性三个特性。

**happens-before**规范 是用来解决**可见性**问题的。**happens-before**也是JMM最核心的概念。

**happens-before** 原则：

+ 程序顺序原则（单线程规则）：在一个单独的线程中，按照程序代码的顺序去执行，保证语义串行性。也就是一个线程中的每个操作，happens-before于该线程中的任意后续操作。

  这里会有个问题，happens-before 关系会不会和重排序冲突？答案是否定的，只要重排序后的结果依然符合 happens-before 关系，能保证可见性的话，那么就不会影响重排序的发生。

+ 锁原则：比如synchronized 和 Lock 接口。解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前，也就是说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个锁)。

+ volatile原则：volatile 变量的写操作 happen-before 后面对该变量的读操作。这保证了volatile变量的可见性。volatile变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，其他线程在读取这个变量的时候一定能读取到该变量最新的值。

+ 线程启动原则（start原则）：如果线程A执行操作ThreadB.start() ，那么A线程的ThreadB.start() 操作 happens-before 于线程B中的任意操作。比如：那么线程A对共享变量的修改在接下来线程B开始执行后确保对线程B可见。

+ 线程join()原则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作 happens-before 于线程A 从ThreadB.join() 操作成功返回。

+ 线程终端原则：对线程 interrupt 方法的调用 happens-before 检测该线程的中断事件。也就是说，如果一个线程被其他线程 interrupt，那么在检测中断时（比如调用 Thread.interrupted 或者 Thread.isInterrupted 方法）一定能看到此次中断的发生，不会发生检测结果不准的情况。

+ 传递性原则：如果A happens-before B，且B happens-before C，那么A happens-before C。

