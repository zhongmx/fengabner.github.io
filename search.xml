<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/04/12/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>docker 安装及常用命令</title>
    <url>/2020/05/23/docker-%E5%AE%89%E8%A3%85%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="环境安装（Linux）"><a href="#环境安装（Linux）" class="headerlink" title="环境安装（Linux）"></a>环境安装（Linux）</h2><h3 id="移除已有docker"><a href="#移除已有docker" class="headerlink" title="移除已有docker"></a>移除已有docker</h3><p>已经安装过docker的，需要进行卸载，卸载的命令官网截图如下：相关的命令内容也会贴出来，我本机刚刚安装的虚拟机，所以跳过这步</p>
<a id="more"></a>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum remove docker \</span></span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>

<h3 id="安装条件"><a href="#安装条件" class="headerlink" title="安装条件"></a>安装条件</h3><p>也就是内核版本，必须是3.10及以上，可以通过uname -r命令检查内核版本</p>
<h3 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h3><p>第一步</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>

<p>第二步</p>
<p>建议使用阿里云的地址，国外的地址，下载比较慢，而且很容易链接超时什么的，两个地址，我都贴出来了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">官网地址</span><br><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#阿里云地址</span></span></span><br><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<p>第三步</p>
<p>正式安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install docker-ce</span><br></pre></td></tr></table></figure>

<p>第四步</p>
<p>启动docker 以及测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line"> </span><br><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>

<h3 id="配置阿里云加速器"><a href="#配置阿里云加速器" class="headerlink" title="配置阿里云加速器"></a>配置阿里云加速器</h3><p>CentOs:</p>
<p>修改配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi usr/lib/systemd/system/docker.service</span><br></pre></td></tr></table></figure>

<p>添加加速器地址 : –registry-mirror=<a href="https://as31ovo6.mirror.aliyuncs.com" target="_blank" rel="noopener">https://as31ovo6.mirror.aliyuncs.com</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ExecStart=/usr/bin/dockerd --registry-mirror=your accelerate address</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">重新加载配制：$ systemctl daemon-reload</span><br><span class="line">重新启动服务：$ systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>查看是否配置成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef|grep docker</span><br></pre></td></tr></table></figure>



<h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker-Compose"></a>Docker-Compose</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载安装</span></span><br><span class="line">curl -L --fail https://github.com/docker/compose/releases/download/1.25.4/run.sh -o /usr/local/bin/docker-compose</span><br><span class="line"><span class="meta">#</span><span class="bash"> 授权</span></span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证是否安装成功</span></span><br><span class="line">docker-compose version</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 卸载</span></span><br><span class="line">rm /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>



<h2 id="docker-常用命令"><a href="#docker-常用命令" class="headerlink" title="docker 常用命令"></a>docker 常用命令</h2><ul>
<li>列出所有的容器 ID</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps -aq</span><br></pre></td></tr></table></figure>

<ul>
<li>查看所有运行或者不运行容器</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>

<ul>
<li>停止所有的容器</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker stop $(docker ps -a -q) 或者 docker stop $(docker ps -aq)</span><br></pre></td></tr></table></figure>

<ul>
<li>删除所有的容器</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm $(docker ps -aq)</span><br></pre></td></tr></table></figure>

<ul>
<li>强制终止并删除一个运行的容器</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm -f 容器ID</span><br></pre></td></tr></table></figure>

<ul>
<li>删除images（镜像），通过image的id来指定删除谁</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rmi &lt;image id&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除所有的镜像</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rmi $(docker images -q)</span><br></pre></td></tr></table></figure>

<ul>
<li>强制删除全部镜像</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rmi -f $(docker images -q)</span><br></pre></td></tr></table></figure>

<ul>
<li>从容器到宿主机复制</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp tomcat：/webapps/js/text.js /home/admin</span><br><span class="line">docker  cp 容器名:  容器路径       宿主机路径</span><br></pre></td></tr></table></figure>

<ul>
<li>从宿主机到容器复制</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp /home/admin/text.js tomcat：/webapps/js</span><br><span class="line">docker cp 宿主路径中文件      容器名  容器路径</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo在文章中添加本地图片</title>
    <url>/2020/05/26/hexo-image-config/</url>
    <content><![CDATA[<p>安装图片插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>在_config.yml配置文件中，修改为 post_asset_folder: true， 然后新建一篇文章</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo n 文章名称</span><br></pre></td></tr></table></figure>

<p>此时会出现一个文件以及跟文件名称相同的文件夹，把图片放到此文件夹中即可</p>
<p><img src="/.com//hexo-image.png" alt></p>
<p>然后在文章中引用就好了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![](test.jpg)</span><br></pre></td></tr></table></figure>



<p>发布之后如果发现图片还是打不开，可使用下面这种方式</p>
<blockquote>
<p>引用 <a href="https://blog.csdn.net/xjm850552586/article/details/84101345" target="_blank" rel="noopener">https://blog.csdn.net/xjm850552586/article/details/84101345</a></p>
</blockquote>
<p>打开/node_modules/hexo-asset-image/index.js，将内容更换为下面的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPosition</span>(<span class="params">str, m, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version = <span class="built_in">String</span>(hexo.version).split(<span class="string">'.'</span>);</span><br><span class="line">hexo.extend.filter.register(<span class="string">'after_post_render'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = hexo.config;</span><br><span class="line">  <span class="keyword">if</span>(config.post_asset_folder)&#123;</span><br><span class="line">    	<span class="keyword">var</span> link = data.permalink;</span><br><span class="line">	<span class="keyword">if</span>(version.length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">	   <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">'/'</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	   <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">'/'</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html".</span></span><br><span class="line">	<span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>;</span><br><span class="line">    link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> toprocess = [<span class="string">'excerpt'</span>, <span class="string">'more'</span>, <span class="string">'content'</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">      <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">var</span> $ = cheerio.load(data[key], &#123;</span><br><span class="line">        ignoreWhitespace: <span class="literal">false</span>,</span><br><span class="line">        xmlMode: <span class="literal">false</span>,</span><br><span class="line">        lowerCaseTags: <span class="literal">false</span>,</span><br><span class="line">        decodeEntities: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">'img'</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> ($(<span class="keyword">this</span>).attr(<span class="string">'src'</span>))&#123;</span><br><span class="line">			<span class="comment">// For windows style path, we replace '\' to '/'.</span></span><br><span class="line">			<span class="keyword">var</span> src = $(<span class="keyword">this</span>).attr(<span class="string">'src'</span>).replace(<span class="string">'\\'</span>, <span class="string">'/'</span>);</span><br><span class="line">			<span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;</span><br><span class="line">			   !<span class="regexp">/^\s*\//</span>.test(src)) &#123;</span><br><span class="line">			  <span class="comment">// For "about" page, the first part of "src" can't be removed.</span></span><br><span class="line">			  <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">			  <span class="keyword">var</span> linkArray = link.split(<span class="string">'/'</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">				<span class="keyword">return</span> elem != <span class="string">''</span>;</span><br><span class="line">			  &#125;);</span><br><span class="line">			  <span class="keyword">var</span> srcArray = src.split(<span class="string">'/'</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">				<span class="keyword">return</span> elem != <span class="string">''</span> &amp;&amp; elem != <span class="string">'.'</span>;</span><br><span class="line">			  &#125;);</span><br><span class="line">			  <span class="keyword">if</span>(srcArray.length &gt; <span class="number">1</span>)</span><br><span class="line">				srcArray.shift();</span><br><span class="line">			  src = srcArray.join(<span class="string">'/'</span>);</span><br><span class="line">			  $(<span class="keyword">this</span>).attr(<span class="string">'src'</span>, config.root + link + src);</span><br><span class="line">			  <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">"update link as:--&gt;"</span>+config.root + link + src);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">"no src attr, skipped..."</span>);</span><br><span class="line">			<span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info($(<span class="keyword">this</span>));</span><br><span class="line">		&#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.html();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>最后推荐使用 cdn 来存储图片。</p>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>java并发之AQS以及ReentrantLock原理</title>
    <url>/2020/07/24/java%E5%B9%B6%E5%8F%91%E4%B9%8BAQS%E4%BB%A5%E5%8F%8AReentrantLock%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><p>AQS 全称是 AbstractQueuedSynchronizer，是一种提供了原子式管理同步状态、阻塞和唤醒线程功能以及队列模型的简单框架。ava中的大部分同步类（Lock、Semaphore、ReentrantLock等）都是基于AQS实现的。</p>
<a id="more"></a>

<h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><p>用 state 属性来表示资源的状态：分独占模式（只有一个线程能执行，如ReentrantLock）和共享模式（多个线程可同时执行，如Semaphore/CountDownLatch），子类需要定义如何维护这个状态，控制如何获取<br>锁和释放锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The synchronization state.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;<span class="comment">//同步状态</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Returns the current value of synchronization state.</span></span><br><span class="line"><span class="comment">  * This operation has memory semantics of a &#123;<span class="doctag">@code</span> volatile&#125; read.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> current state value</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;<span class="comment">//获取同步状态</span></span><br><span class="line">     <span class="keyword">return</span> state;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Sets the value of synchronization state.</span></span><br><span class="line"><span class="comment">  * This operation has memory semantics of a &#123;<span class="doctag">@code</span> volatile&#125; write.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> newState the new state value</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;<span class="comment">//设置同步状态</span></span><br><span class="line">     state = newState;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Atomically sets synchronization state to the given updated</span></span><br><span class="line"><span class="comment">  * value if the current state value equals the expected value.</span></span><br><span class="line"><span class="comment">  * This operation has memory semantics of a &#123;<span class="doctag">@code</span> volatile&#125; read</span></span><br><span class="line"><span class="comment">  * and write.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful. False return indicates that the actual</span></span><br><span class="line"><span class="comment">  *         value was not equal to the expected value.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;<span class="comment">//CAS操作设置同步状态</span></span><br><span class="line">     <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">     <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h2><p>AQS采用的模板方法模式，自定义同步器(ReentrantLock为例)需要实现以下方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*	独占方式。arg为获取锁的次数，尝试获取资源，成功则返回True，失败则返回False。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*	独占方式。arg为释放锁的次数，尝试释放资源，成功则返回True，失败则返回False。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*	共享方式。arg为获取锁的次数，尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*	共享方式。arg为释放锁的次数，尝试释放资源，如果释放后允许唤醒后续等待结点返回True，否则返回False。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*	该线程是否正在独占资源。只有用到Condition才需要去实现它。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h2 id="CLH队列"><a href="#CLH队列" class="headerlink" title="CLH队列"></a>CLH队列</h2><h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><p>CLH(Craig, Landin, and Hagersten)锁，是自旋锁的一种。AQS中使用了CLH锁的一个变种，实现了一个虚拟双向队列（FIFO），队列头节点称作“哨兵节点”或者“哑节点”，它不与任何线程关联。其他的节点与等待线程关联，每个节点维护一个等待状态waitStatus。</p>
<p><img src="/.com//CLH.png" alt="CLH"></p>
<h3 id="数据结构NODE"><a href="#数据结构NODE" class="headerlink" title="数据结构NODE"></a>数据结构NODE</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">     <span class="comment">/** 表示线程以共享的模式等待锁 */</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">     <span class="comment">/** 表示线程正在以独占的方式等待锁 */</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/** waitStatus=1 说明当前结点(即相应的线程)是因为超时或者中断取消的，进入该状态后将无法恢复 */</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">     <span class="comment">/** waitStatus=-1 表示后继结点在等待当前结点唤醒。后继结点入队时，会将前继结点的状态更新为							* SIGNAL。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">     <span class="comment">/** waitStatus=-2 该状态是用于condition队列结点的。明结点在等待队列中，结点线程等待在Condition				 *	上，当其他线程对Condition调用了signal()方法时，会将其加入到同步队列中去。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * waitStatus=-3 共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点(无条件					 * 地向后继结点传播)。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 等待状态。 =0，初始化的时候的默认值</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 前置节点（前驱指针）</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 后置节点（后继指针）</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 表示当前节点的线程</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 用于记录共享模式(SHARED)。也可以用来记录CONDITION队列，指向下一个处于CONDITION状态的节点					 *（Condition Queue队列）</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     Node nextWaiter;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 通过nextWaiter的记录值判断当前结点的模式是否为共享模式</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 返回前驱节点</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">         Node p = prev;</span><br><span class="line">         <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             <span class="keyword">return</span> p;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">         <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">         <span class="keyword">this</span>.thread = thread;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">         <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">         <span class="keyword">this</span>.thread = thread;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 头节点</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 尾节点</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br></pre></td></tr></table></figure>

<p><img src="/.com//FIFO.png" alt="FIFO"></p>
<h2 id="手动实现一个简单-ReentrantLock"><a href="#手动实现一个简单-ReentrantLock" class="headerlink" title="手动实现一个简单 ReentrantLock"></a>手动实现一个简单 ReentrantLock</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySelfLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//state 表示获取到锁  state =1获取到了锁，state=0，表示这个锁当前没有线程拿到</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//是否独占</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//独占式 获取</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>,<span class="number">1</span>))&#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//独占式 释放</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (getState() ==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">            &#125;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            setState(<span class="number">0</span>);<span class="comment">//不会有多个线程竞争，不需要使用原子性</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//加锁 不成功进入等待队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//加锁 可打断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//尝试加锁（一次）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//尝试加锁 带超时的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>,unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMyLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> MySelfLock();<span class="comment">//new ReentrantLock();</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">                        System.out.println(Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        lock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            Worker w = <span class="keyword">new</span> Worker();</span><br><span class="line">            w.setName(<span class="string">"线程=="</span>+i);</span><br><span class="line">            w.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">            w.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(<span class="string">"*****************************"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestMyLock testMyLock = <span class="keyword">new</span> TestMyLock();</span><br><span class="line">        testMyLock.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">线程==0</span><br><span class="line">*****************************</span><br><span class="line">*****************************</span><br><span class="line">线程==1</span><br><span class="line">*****************************</span><br><span class="line">*****************************</span><br><span class="line">线程==2</span><br><span class="line">*****************************</span><br><span class="line">*****************************</span><br><span class="line">*****************************</span><br><span class="line">线程==3</span><br><span class="line">*****************************</span><br><span class="line">线程==4</span><br><span class="line">*****************************</span><br><span class="line">*****************************</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<h1 id="ReentrantLock-原理浅析"><a href="#ReentrantLock-原理浅析" class="headerlink" title="ReentrantLock 原理浅析"></a>ReentrantLock 原理浅析</h1><h2 id="非公平锁实现原理"><a href="#非公平锁实现原理" class="headerlink" title="非公平锁实现原理"></a>非公平锁实现原理</h2><h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><h4 id="lock"><a href="#lock" class="headerlink" title="lock()"></a>lock()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))<span class="comment">//cas 设置state的值 更新为1	</span></span><br><span class="line">    setExclusiveOwnerThread(Thread.currentThread());<span class="comment">//设置当前线程为锁的持有者</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>调用 <strong>CAS</strong> 方法去设置 state的值，如果 state 的值等于0，代表锁没有被占用，那么就将state值更新为1，代表该线程获取锁成功，然后执行<strong>setExclusiveOwnerThread</strong> 方法将该线程设置为锁的<strong>持有者</strong>。</li>
<li>如果<strong>CAS</strong> 设置state的值失败，也就是 state 不等于0，此时锁正在被占用着，则要执行 <strong>acquire</strong> 方法</li>
</ul>
<h4 id="acquire"><a href="#acquire" class="headerlink" title="acquire()"></a>acquire()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  *如果 tryAcquire 为true，这个取反就变为false了，就不会执行后面的了。如果tryAcquire 返回false ，取反就为true，会继续执</span></span><br><span class="line"><span class="comment">  *行后面的 acquireQueued</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; </span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) </span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先调用 <strong>tryAcquire</strong> 再次进行尝试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">  <span class="keyword">int</span> c = getState();</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;<span class="comment">//如果 state 的值等于0（之前占有锁的线程刚好已经释放了锁）</span></span><br><span class="line">   	<span class="comment">// 尝试用 cas 获得, 这里体现了非公平性: 不去检查 AQS 队列</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">//CAS 将state的值更新为1。</span></span><br><span class="line">      setExclusiveOwnerThread(current);<span class="comment">//设置当前线程为锁的持有者</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 查看占有锁的线程是不是刚好是自己,如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">    <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">    <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">    setState(nextc);<span class="comment">// 更新重入次数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>调用 getState() 方法获取 state 的值，如果 state 的值等于0（之前占有锁的线程刚好已经释放了锁）</p>
<ul>
<li><p>则 CAS 将state的值更新为1。</p>
</li>
<li><p>CAS  如果成功，然后执行<strong>setExclusiveOwnerThread</strong> 方法将该线程设置为锁的<strong>持有者</strong>。</p>
</li>
<li><p>CAS  如果失败，则直接返回false。</p>
</li>
</ul>
</li>
<li><p>如果 state 的值不等于0</p>
<ul>
<li>调用 <strong>getExclusiveOwnerThread</strong> 方法查看占有锁的线程是不是刚好是自己。（重入）</li>
<li>如果是，则将 state+1，然后返回true。</li>
<li>如果不是，则直接返回 false。</li>
</ul>
</li>
</ul>
<h4 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter()"></a>addWaiter()</h4><p>入队操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前线程构造成Node节点。mode有两种：EXCLUSIVE（独占）和SHARED（共享） </span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;<span class="comment">//尾节点不为空</span></span><br><span class="line">      node.prev = pred; <span class="comment">//当前线程节点的前驱节点指向尾节点</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//并发处理 尾节点有可能已经不是之前的节点 所以需要CAS更新</span></span><br><span class="line">      <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">        pred.next = node; <span class="comment">//CAS更新成功 当前线程为尾节点 原先尾节点的后续节点就是当前节点</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尾节点为空，说明队列还没有初始化，需要初始化</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>如果 pred == null 需要执行 enq() 方法</p>
<p><font color="red"><strong>队列初始化的时候，创建的头节点是一个哨兵节点，并不会跟任务线程相关联</strong></font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;<span class="comment">//自旋操作</span></span><br><span class="line">      Node t = tail;</span><br><span class="line">      <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">        <span class="comment">//尾节点为空  第一次入队  设置头尾节点一致 同步队列的初始化。注意此时初始化的头节点并不是吧当前节点设置为头节点，这个头节点可以看成是一个哨兵节点，并不会跟任何线程相关联</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">          tail = head;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//所有的线程节点在构造完成第一个节点后 依次加入到同步队列中</span></span><br><span class="line">        node.prev = t;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">          t.next = node;</span><br><span class="line">          <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/.com//AQS_node1.png" alt="AQS_node1"></p>
<h4 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued()"></a>acquireQueued()</h4><p>挂起。会在一个死循环中不断尝试获得锁，失败后进入 park 阻塞</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>; <span class="comment">//标记线程是否被中断过</span></span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">final</span> Node p = node.predecessor(); <span class="comment">//获取前驱节点</span></span><br><span class="line">        <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="comment">//如果前驱节点是头节点，则再次尝试获取锁</span></span><br><span class="line">          setHead(node); <span class="comment">// 获取成功,将当前节点设置为head节点</span></span><br><span class="line">          p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">          failed = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">return</span> interrupted; <span class="comment">//返回是否被中断过</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 判断获取失败后当前线程是否可以挂起,若可以则挂起</span></span><br><span class="line"><span class="comment">        * 注意：</span></span><br><span class="line"><span class="comment">        * shouldParkAfterFailedAcquire 将前驱 node，即 head 的 waitStatus 改为 -1，这次返回 false，返回acquireQueued				*		再次尝试获取锁</span></span><br><span class="line"><span class="comment">        * 再次进入 shouldParkAfterFailedAcquire 时，这时因为其前驱 node 的 waitStatus 已经是 -1，这次返回 true</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">            parkAndCheckInterrupt())</span><br><span class="line">          interrupted = <span class="keyword">true</span>; <span class="comment">//返回是否被中断过</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (failed)</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>shouldParkAfterFailedAcquire()。主要当前节点的前驱节点状态是否符合要求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ws = pred.waitStatus; <span class="comment">//前驱节点的状态</span></span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *  前驱节点状态为signal (-1 表示后继结点在等待当前结点唤醒),返回true</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 从队尾向前寻找第一个状态不为CANCELLED的节点</span></span><br><span class="line"><span class="comment">             * </span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">             * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">             * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">             * 将前驱节点的状态设置为SIGNAL (-1)</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>整个挂起逻辑如下：</p>
<p>进入acquireQueued 逻辑</p>
<ul>
<li>获取前驱节点，final Node p = node.predecessor();</li>
<li>如果前驱节点是头节点，则再次尝试获取锁，tryAcquire(arg);</li>
<li>尝试获取锁成功,将当前节点设置为head节点</li>
<li>如果前驱节点不是头节点，或者尝试获取锁失败，则进行入队操作。shouldParkAfterFailedAcquire();</li>
</ul>
<p>进入 shouldParkAfterFailedAcquire 逻辑</p>
<ul>
<li>将前驱 node，即 head 的 waitStatus 改为 -1(<font color="red">表示后继结点在等待当前结点唤醒</font>)，这次返回 <font color="red">false</font></li>
<li>shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued ，再次 tryAcquire 尝试获取锁，如果这时<br>state 仍为 1，则获取锁失败。</li>
<li>再次进入 shouldParkAfterFailedAcquire 时，这时因为其前驱 node 的 waitStatus 已经是 -1，这次返回<br><font color="red">true</font></li>
<li>进入 parkAndCheckInterrupt，将自己挂起。</li>
</ul>
<h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;<span class="comment">// 尝试释放锁，返回true代表已经全部释放成功</span></span><br><span class="line">            Node h = head;<span class="comment">// 获取头结点</span></span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">              	<span class="comment">/*</span></span><br><span class="line"><span class="comment">              	* 头结点不为空并且头结点的waitStatus不是初始化节点情况，解除线程挂起状态，唤醒头结点的下个节点关联的线程</span></span><br><span class="line"><span class="comment">              	*/</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState() - releases;<span class="comment">// 计算减少可重入次数</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<span class="comment">// 判断当前线程不是持有锁的线程，抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;<span class="comment">// 锁被重入次数为0,表示释放成功，清空独占线程</span></span><br><span class="line">                free = <span class="keyword">true</span>;</span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">  					<span class="comment">//更新state</span></span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<p><strong>唤醒处理</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">         * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">         * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> ws = node.waitStatus; <span class="comment">// 获取头结点waitStatus</span></span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">         * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">         * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">         * non-cancelled successor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node s = node.next; <span class="comment">// 获取当前节点的下一个节点</span></span><br><span class="line">  			<span class="comment">/*</span></span><br><span class="line"><span class="comment">  			* 如果下个节点是null或者下个节点被cancelled，就找到队列最开始的非cancelled的节点</span></span><br><span class="line"><span class="comment">  			*/</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="keyword">null</span>;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">          * 从尾部节点开始找，到队首，找到队列第一个waitStatus&lt;0的节点。</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">            <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>) <span class="comment">//从这里可以看出，&lt;=0的结点，都是还有效的结点</span></span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">  			<span class="comment">/*</span></span><br><span class="line"><span class="comment">  			* 如果当前节点的下个节点不为空，而且状态&lt;=0，就把下一个节点unpark</span></span><br><span class="line"><span class="comment">  			*/</span></span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><font color="red"><strong>为什么要从后往前节点？</strong></font></p>
<p>主要是因为入队操作不是原子性的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">      node.prev = pred; <span class="comment">//还未开始执行，此时执行了 unparkSuccessor 方法的的时候</span></span><br><span class="line">      <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">        pred.next = node; </span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个原因：入队操作不是原子性的，当pred.next = node还没执行，如果这个时候执行了unparkSuccessor方法，就没办法从前往后找了，所以需要从后往前找。</li>
<li>第二个原因：在产生CANCELLED状态节点的时候，先断开的是Next指针，Prev指针并未断开，因此也是必须要从后往前遍历才能够遍历完全部的Node</li>
</ul>
<h2 id="可打断原理"><a href="#可打断原理" class="headerlink" title="可打断原理"></a>可打断原理</h2><h3 id="不可打断模式"><a href="#不可打断模式" class="headerlink" title="不可打断模式"></a>不可打断模式</h3><p>在此模式下，即使它被打断，仍会驻留在 AQS 队列中，一直要等到获得锁后方能得知自己被打断了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>); <span class="comment">// 如果打断标记已经是 true, 则 park 会失效</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted(); <span class="comment">// interrupted 会清除打断标记</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted; <span class="comment">//需要获得锁后, 才能返回打断状态</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>; <span class="comment">// 如果是因为 interrupt 被唤醒, 返回打断状态为 true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">      selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread.currentThread().interrupt(); <span class="comment">// 重新产生一次中断</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="可打断模式"><a href="#可打断模式" class="headerlink" title="可打断模式"></a>可打断模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg)) <span class="comment">// 如果没有获得到锁, 执行 doAcquireInterruptibly</span></span><br><span class="line">            doAcquireInterruptibly(arg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                  <span class="comment">// 在 park 过程中如果被 interrupt 会进入此</span></span><br><span class="line">									<span class="comment">// 这时候抛出异常, 而不会再次进入 for (;;)</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="公平锁实现原理"><a href="#公平锁实现原理" class="headerlink" title="公平锁实现原理"></a>公平锁实现原理</h2><h3 id="加锁-1"><a href="#加锁-1" class="headerlink" title="加锁"></a>加锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="red">与非公平锁主要区别在于 tryAcquire 方法的实现</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">  	<span class="comment">//判断状态state是否等于0，等于0代表锁没有被占用，不等于0则代表锁被占用着。</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断当前线程是否为锁的所有者，如果是，那么直接更新状态state，然后返回true。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//如果同步队列中有线程存在 且 锁的所有者不是当前线程，则返回false。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = tail; </span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">  	<span class="comment">// h != t 时表示队列中有 Node</span></span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">      	<span class="comment">/*</span></span><br><span class="line"><span class="comment">      	* (s = h.next) == null 表示队列中没有第二个节点了 （第一个节点是头节点不与任何线程相关联）</span></span><br><span class="line"><span class="comment">      	* || s.thread != Thread.currentThread() 或者队列中第二个线程不是此线程</span></span><br><span class="line"><span class="comment">      	*/</span></span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>调用hasQueuedPredecessors方法判断同步队列中是否有线程在等待。</li>
<li>如果同步队列中没有线程在等待，则当前线程成为锁的所有者。</li>
<li>如果同步队列中有线程在等待，则继续往下执行。</li>
<li>这个机制就是公平锁的机制，也就是先让先来的线程获取锁，后来的不能抢先获取</li>
</ul>
<h3 id="解锁-1"><a href="#解锁-1" class="headerlink" title="解锁"></a>解锁</h3><p>解锁与非公平锁一致。</p>
<p><strong>参考资料</strong></p>
<p><a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html" target="_blank" rel="noopener">从ReentrantLock的实现看AQS的原理及应用</a></p>
]]></content>
      <categories>
        <category>java 并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>java并发之JMM</title>
    <url>/2020/07/07/java%E5%B9%B6%E5%8F%91%E4%B9%8BJMM/</url>
    <content><![CDATA[<h1 id="区别Java内存结构与Java内存模型"><a href="#区别Java内存结构与Java内存模型" class="headerlink" title="区别Java内存结构与Java内存模型"></a>区别Java内存结构与Java内存模型</h1><p>概述：这两个概念比较容易混淆。JVM 内存结构和 Java 虚拟机的运行时区域有关，Java 内存模型（JMM）和 Java 的并发编程有关。</p>
<a id="more"></a>

<h2 id="Java-内存结构"><a href="#Java-内存结构" class="headerlink" title="Java 内存结构"></a>Java 内存结构</h2><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>​        较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器。线程私有的内存区域。唯一一个区域没有任何OutOfMemoryError的区域。</p>
<p>​        线程执行的是一个Java方法，则计数器指示需要执行的字节码指令地址；如果执行的是Native方法，这个计数器的值为空。这个内存区域是唯一一个在Java规范中没有规定任何OutOfMemoryError情况的区域。</p>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>​        栈帧是方法运行期的基础数据结构栈容量可由-Xss参数设定。</p>
<p>​        线程私有，生命周期与线程相同。描述的是java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧，存储了局部变量表、操作数栈、动态链接、方法出口等信息。一个方法的调用直至执行完，就相当于是一个栈帧在虚拟机中入栈到出栈。<br>​        局部变量表：存放了编译期可知的各种基本数据类型、对象引用和returnAddress类型。局部变量表所需的内存空间在编译期间完成分配。</p>
<p>​        有可能抛出两个异常</p>
<pre><code>+ StackOverFlowError  如果线程请求的栈深度大于虚拟机所允许的深度
+ OutOfMemoryError  如果虚拟机栈可以动态扩展，扩展时无法申请到足够内存</code></pre><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>​        本地方法栈与虚拟机栈所发挥的作用非常相似，只不过JVM Stacks是为虚拟机执行Java方法（字节码）服务的，而本地方法栈则是为JVM使用Native方法服务的。甚至有的虚拟机（Sun hotspot虚拟机）直接把本地方法栈和虚拟机栈合二为一，虚拟机栈一样，也会抛出StackOverFlowError和OutOfMemoryError异常。</p>
<h3 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h3><p>​        可通过参数 -Xms 和-Xmx设置。</p>
<p>​        线程共享，虚拟机启动时创建，唯一目的就是存放对象实例，从内存回收的角度。</p>
<p>​        细分为新生代（Eden空间、From Survivor、To Survivor），老年代。java堆可以处于物理上不连续的空间。如果堆中没有内存完成实例分配，并且堆也无法扩展，将抛出 OutOfMemoryError。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>​        可以通过-XX:PermSize和-XX:MaxPermSize设置[^ 1]。</p>
<p>​        线程共享，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。java虚拟机规范也把方法区作为堆的一个逻辑部分。垃圾收集行为在这个内存区域是较少出现的，这个区域内存回收的目的主要是针对常量池的回收和对类型的卸载。当方法区无法满足内存分配需求时抛 OutOfMemoryError。</p>
<blockquote>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>方法区的一部分，用于存放编译器生成的各种字面量和符号引用。这部分内容将在类加载后进入方法区的运行时常量池中存放。运行期间也可能将新的常量放入池中。如String的intern()方法。</p>
</blockquote>
<h1 id="Java-内存模型（JMM是什么-）"><a href="#Java-内存模型（JMM是什么-）" class="headerlink" title="Java 内存模型（JMM是什么?）"></a>Java 内存模型（JMM是什么?）</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java 内存模型（Java Memory Model  JMM  ）是一组规范。来屏蔽掉各种硬件和操作系统的内存访问差异， 以实现让Java程序在各种平台下都能达到一致的内存访问效果。  </p>
<p>JMM 与处理器、缓存、并发、编译器有关。它解决了 CPU 多级缓存、处理器优化、指令重排等导致的结果不可预期的问题。</p>
<h2 id="内存划分"><a href="#内存划分" class="headerlink" title="内存划分"></a>内存划分</h2><p>JMM规定了内存主要划分为<strong>主内存</strong>和<strong>工作内存</strong>两种。此处的主内存和工作内存跟JVM内存划分（堆、栈、方法区）是在不同的层次上进行的，如果非要对应起来，主内存对应的是Java堆中的对象实例部分，工作内存对应的是栈中的部分区域，从更底层的来说，主内存对应的是硬件的物理内存，工作内存对应的是寄存器和高速缓存。</p>
<p>Java 内存模型中规定了所有的变量都存储在主内存中（类比物理硬件的主内存），每个线程还有自己的工作内存（类比高速缓存），线程的工作内存中保存了被该线程使用到主内存中的变量拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成。</p>
<p><a href="https://s0.lgstatic.com/i/image3/M01/00/EF/Ciqah154fUGAS19LAAGap07f1AU762.png" target="_blank" rel="noopener">图片来源于网络</a></p>
<p><img src="/.com//jmm.png" alt="jmm"></p>
<h2 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h2><p>java内存模型中定义了一套规范，8种操作，虚拟机实现必须保证每一个操作都是原子的，不可在分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许例外）</p>
<ul>
<li>lock   （锁定）：作用于主内存的变量，把一个变量标识为线程独占状态</li>
<li>unlock （解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li>
<li>read  （读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用</li>
<li>load   （载入）：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中</li>
<li>use   （使用）：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令</li>
<li>assign （赋值）：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中</li>
<li>store  （存储）：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用</li>
<li>write 　（写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中</li>
</ul>
<p>如果要把一个变量从主内存中复制到工作内存，就需要按顺序地执行 read 和 load 操作，如果把变量从工作内存同步回主内存中，就要按顺序地执行 store 和 write 操作。Java 内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。也就是 read 和 load 之间，store 和 write 之间是可以插入其他指令的，如对主内存中的变量 a、b 进行访问时，可能的顺序是 read a，read b，load b， load a。Java 内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：</p>
<ul>
<li>不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write</li>
<li>不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存</li>
<li>不允许一个线程将没有assign的数据从工作内存同步回主内存</li>
<li>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作</li>
<li>一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁</li>
<li>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值</li>
<li>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量</li>
<li>对一个变量进行unlock操作之前，必须把此变量同步回主内存</li>
</ul>
<h1 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h1><p>Java内存模型是围绕着并发编程中原子性、可见性、有序性这三个特征来建立的。这也是Java解决多线程并行机制的环境下，制定出的一种规则，能够保证多个线程间可以有效地、正确地协同工作。</p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p><strong>原子性</strong>是指一个操作是不可中断的，要么全部执行完毕，要么不执行。</p>
<p>基本类型数据的访问大都是原子操作，long 和double类型的变量是64位，但是在32位JVM中，32位的JVM会将64位数据的读写操作分为2次32位的读写操作来进行，这就导致了long、double类型的变量在32位虚拟机中是非原子操作，数据有可能会被破坏，也就意味着多个线程在并发访问的时候是线程非安全的。</p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>可见性是指当一个线程修改了共享变量的值， 其他线程能够立即得知这个修改 。</p>
<p>比如</p>
<p><strong>synchronized</strong> 当线程获取锁时会从主内存中获取共享变量的最新值，释放锁的时候会将共享变量同步到主内存中。</p>
<p><strong>volatile</strong>也具备可见性，volatile的特殊规则保证了volatile变量值修改后的新值立刻同步到主内存，每次使用volatile变量前立即从主内存中刷新，因此volatile保证了多线程之间的操作变量的可见性。</p>
<p>除此之外，<strong>Lock、final 都可以保证变量的可见性。</strong></p>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>Java内存模型中，允许编译器和处理器对指令进行<strong>重排序</strong>，但是<strong>重排序</strong>的过程不会影响单线程的执行结果，却会影响到多线程并发执行的正确性。</p>
<p>题外话：为什么要重排序？</p>
<p>“<strong>重排序是对内存访问操作的一种优化，他可以在不影响单线程程序正确性的前提下进行一定的调整，进而提高程序的性能</strong>。<strong>但是对于多线程场景下，就可能产生一定的问题</strong>”</p>
<p><strong>有序性的意思就是说 Java 内存模型中的指令重排不会影响单线程的执行顺序，但是会影响多线程并发执行的正确性，</strong>所以在并发中我们必须要想办法保证并发代码的有序性。</p>
<p>volatile， synchronized，Lock，可以保证有序性。</p>
<h1 id="happens-before-原则"><a href="#happens-before-原则" class="headerlink" title="happens-before 原则"></a>happens-before 原则</h1><p>通过对Java内存模型的了解，JMM<strong>目的是保证并发场景中的原子性、可见性和有序性。JMM处理并发问题主要采用两种方式：限制处理器优化和使用内存屏障。</strong>在并发编程当中为了保证数据的安全，必须满足原子性、可见性和有序性三个特性。</p>
<p><strong>happens-before</strong>规范 是用来解决<strong>可见性</strong>问题的。<strong>happens-before</strong>也是JMM最核心的概念。</p>
<p><strong>happens-before</strong> 原则：</p>
<ul>
<li><p>程序顺序原则（单线程规则）：在一个单独的线程中，按照程序代码的顺序去执行，保证语义串行性。也就是一个线程中的每个操作，happens-before于该线程中的任意后续操作。</p>
<p>这里会有个问题，happens-before 关系会不会和重排序冲突？答案是否定的，只要重排序后的结果依然符合 happens-before 关系，能保证可见性的话，那么就不会影响重排序的发生。</p>
</li>
<li><p>锁原则：比如synchronized 和 Lock 接口。解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前，也就是说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个锁)。</p>
</li>
<li><p>volatile原则：volatile 变量的写操作 happen-before 后面对该变量的读操作。这保证了volatile变量的可见性。volatile变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，其他线程在读取这个变量的时候一定能读取到该变量最新的值。</p>
</li>
<li><p>线程启动原则（start原则）：如果线程A执行操作ThreadB.start() ，那么A线程的ThreadB.start() 操作 happens-before 于线程B中的任意操作。比如：那么线程A对共享变量的修改在接下来线程B开始执行后确保对线程B可见。</p>
</li>
<li><p>线程join()原则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作 happens-before 于线程A 从ThreadB.join() 操作成功返回。</p>
</li>
<li><p>线程终端原则：对线程 interrupt 方法的调用 happens-before 检测该线程的中断事件。也就是说，如果一个线程被其他线程 interrupt，那么在检测中断时（比如调用 Thread.interrupted 或者 Thread.isInterrupted 方法）一定能看到此次中断的发生，不会发生检测结果不准的情况。</p>
</li>
<li><p>传递性原则：如果A happens-before B，且B happens-before C，那么A happens-before C。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>java 并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>java并发之park和unpark</title>
    <url>/2020/07/02/java%E5%B9%B6%E5%8F%91%E4%B9%8Bpark%E5%92%8Cunpark/</url>
    <content><![CDATA[<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h2 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h2><ul>
<li>LockSupport.park(); 暂停当前线程</li>
<li>LockSupport.unpark(); 恢复某个线程的运行</li>
</ul>
<a id="more"></a>

<h2 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h2><p>先park再unpark</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParkUnparkOneTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">"start..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">"park..."</span>);</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            log.debug(<span class="string">"resume..."</span>);</span><br><span class="line">        &#125;, <span class="string">"t1"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">"unpark..."</span>);</span><br><span class="line">        LockSupport.unpark(t1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">23:51:57.941 [t1] DEBUG com.fengabner.business.ParkUnparkOneTest - start...</span><br><span class="line">23:51:58.950 [t1] DEBUG com.fengabner.business.ParkUnparkOneTest - park...</span><br><span class="line">23:51:59.943 [main] DEBUG com.fengabner.business.ParkUnparkOneTest - unpark...</span><br><span class="line">23:51:59.943 [t1] DEBUG com.fengabner.business.ParkUnparkOneTest - resume...</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<p>先unpark再park</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParkUnparkTwoTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">"start..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">"park..."</span>);</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            log.debug(<span class="string">"resume..."</span>);</span><br><span class="line">        &#125;, <span class="string">"t1"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">"unpark..."</span>);</span><br><span class="line">        LockSupport.unpark(t1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">23:56:50.996 [t1] DEBUG com.fengabner.business.ParkUnparkTwoTest - start...</span><br><span class="line">23:56:51.999 [main] DEBUG com.fengabner.business.ParkUnparkTwoTest - unpark...</span><br><span class="line">23:56:53.004 [t1] DEBUG com.fengabner.business.ParkUnparkTwoTest - park...</span><br><span class="line">23:56:53.004 [t1] DEBUG com.fengabner.business.ParkUnparkTwoTest - resume...</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<h1 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h1><p>每个java线程都有一个Parker实例，Parker类定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parker</span> :</span> <span class="keyword">public</span> os::PlatformParker &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> _counter ;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">bool</span> isAbsolute, jlong time)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unpark</span><span class="params">()</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlatformParker</span> :</span> <span class="keyword">public</span> CHeapObj&lt;mtInternal&gt; &#123;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> _mutex [<span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">pthread_cond_t</span>  _cond  [<span class="number">1</span>] ;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Parker 对象，由三部分组成 _counter ， _cond 和 _mutex。Parker类里的 _counter字段，就是用来记录所谓的“许可”的。</p>
<p><strong>先调用park</strong></p>
<p><img src="/.com//image-20200630003257340.png" alt="image-20200630003257340"></p>
<p>当调用park时，先去尝试能否直接拿到“许可”，也就时 _counter&gt;0，如果成功，则把 _counter 设置为0，并返回。如果不成功，则把  _counter设置为0，获得 _mutex 互斥锁。</p>
<p><strong>再调用 unpark</strong></p>
<p>1、设置 _counter为1</p>
<p>2、唤醒 _cond 条件变量中的 Thread_0</p>
<p>3、Thread_0 恢复运行</p>
<p>4、设置 _counter 为 0</p>
<p><strong>先调用 unpark 再调用 park</strong></p>
<p><img src="/.com//image-20200630004037812.png" alt="image-20200630004037812"></p>
<p>1、调用 unpark ,设置_counter 为 1</p>
<p>2、当前线程调用 park，检查 _counter，此时 _counter 为1，这是线程无需阻塞，继续运行</p>
<p>3、设置 _counter 为0</p>
<h1 id="对比-wait-notify"><a href="#对比-wait-notify" class="headerlink" title="对比 wait/notify"></a>对比 wait/notify</h1><ul>
<li>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用（必须使用synchronized加锁），而 park，unpark 不必</li>
<li>park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么【精确】</li>
<li>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify</li>
</ul>
<h1 id="固定顺序执行"><a href="#固定顺序执行" class="headerlink" title="固定顺序执行"></a>固定顺序执行</h1><p>比如，必须先 2 后 1 打印</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParkUnparkThreeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            LockSupport.park(); <span class="comment">//暂停等待'</span></span><br><span class="line">            log.debug(<span class="string">"1"</span>);</span><br><span class="line">        &#125;, <span class="string">"t1"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">"2"</span>);</span><br><span class="line">            LockSupport.unpark(t1); <span class="comment">//唤醒t1</span></span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">23:46:46.438 [t2] DEBUG com.fengabner.business.ParkUnparkThreeTest - 2</span><br><span class="line">23:46:46.443 [t1] DEBUG com.fengabner.business.ParkUnparkThreeTest - 1</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<h1 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h1><p>例子：交替打印 abc</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParkUnparkFourTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> loopNums;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Thread t1, t2, t3;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParkUnparkFourTest</span><span class="params">(<span class="keyword">int</span> loopNums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loopNums = loopNums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String message, Thread nextThread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNums; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            LockSupport.park();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//打印输出并唤醒下一个线程</span></span><br><span class="line">            System.out.print(message);</span><br><span class="line">            LockSupport.unpark(nextThread);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ParkUnparkFourTest parkUnparkFourTest = <span class="keyword">new</span> ParkUnparkFourTest(<span class="number">10</span>);</span><br><span class="line">        t1 = <span class="keyword">new</span> Thread(() -&gt; parkUnparkFourTest.print(<span class="string">"a"</span>, t2));</span><br><span class="line">        t2 = <span class="keyword">new</span> Thread(() -&gt; parkUnparkFourTest.print(<span class="string">"b"</span>, t3));</span><br><span class="line">        t3 = <span class="keyword">new</span> Thread(() -&gt; parkUnparkFourTest.print(<span class="string">"c"</span>, t1));</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">        LockSupport.unpark(t1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abcabcabcabcabcabcabcabcabcabc</span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>



<p><strong>参考资料</strong></p>
<p><a href="https://www.bilibili.com/video/BV16J411h7Rd?p=109" target="_blank" rel="noopener">全面深入了解并发编程</a></p>
]]></content>
      <categories>
        <category>java 并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>java并发之ReentrantLock简单介绍</title>
    <url>/2020/07/17/java%E5%B9%B6%E5%8F%91%E4%B9%8BReentrantLock%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="ReentrantLock-简单介绍"><a href="#ReentrantLock-简单介绍" class="headerlink" title="ReentrantLock 简单介绍"></a>ReentrantLock 简单介绍</h1><p>ReentrantLock是实现了Lock接口。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>支持可重入</li>
<li>可中断</li>
<li>支持公平锁和非公平锁</li>
<li>支持多个条件变量设置</li>
<li>可以设置超时时间</li>
</ul>
<a id="more"></a>

<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>ReentrantLock 中的 lock 和 unlock 是需要成对出现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock() ;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">         lock.lock();<span class="comment">//加锁</span></span><br><span class="line">    &#125;  <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Lock-api"><a href="#Lock-api" class="headerlink" title="Lock api"></a>Lock api</h1><p><img src="/.com//image-20200804165753248.png" alt="image-20200804165753248"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 获取锁，若当前lock已经被其他线程获取时,则当前线程会被阻塞一直到lock被释放。采用lock,必须主动去释放锁，并且在发生异常时，不会自动释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取锁，若当前锁不可用,则当前线程会被阻塞,等待获取锁，在等待过程中这个线程能够响应中断，即中断线程的等待状态,会抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取锁，如果获取成功，则返回true,如果获取失败（即锁已被其他线程获取），则返回false。这个方法无论如何都会立即返回</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果锁在给定等待时间内没有被另一个线程持有，并且当前线程未被中断，则获取该锁</span></span><br><span class="line">    <span class="comment">// 等待过程中，可以被中断</span></span><br><span class="line">    <span class="comment">// 超过时间，依然获取不到，则返回false；否则返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个绑定该lock的Condtion对象</span></span><br><span class="line">    <span class="comment">// 在Condition await()之前，锁会被该线程持有</span></span><br><span class="line">    <span class="comment">// Condition await()之后 会自动释放锁，在wait返回之后，会自动获取锁</span></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ReentrantLock-api"><a href="#ReentrantLock-api" class="headerlink" title="ReentrantLock api"></a>ReentrantLock api</h1><p><img src="/.com//image-20200730144344679.png" alt="image-20200730144344679"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span><span class="comment">// 默认非公平锁</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span><span class="comment">// fair为true表示是公平锁，fair为false表示是非公平锁</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span><span class="comment">// 获取锁</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span><span class="comment">// 中断等待获取锁的线程,如果当前线程未被中断,则去获取锁,已被中断则抛异常</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span><span class="comment">// 在调用时,锁如果没有被另一个线程持有的情况下，才获取该锁</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span><span class="comment">// 如果锁在给定等待时间内没有被另一个线程持有，并且当前线程未被中断，则获取该锁</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span><span class="comment">// 释放锁</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span><span class="comment">// 返回用来与此 Lock 实例一起使用的 Condition 实例</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHoldCount</span><span class="params">()</span><span class="comment">// 查询当前线程保持锁定的个数，也就是调用lock()方法的个数</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHeldByCurrentThread</span><span class="params">()</span><span class="comment">// 查询当前线程是否持有此锁</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span><span class="comment">// 查询此锁是否由任意线程所持有</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isFair</span><span class="params">()</span><span class="comment">// 判断是否是公平锁,如果是公平锁返回true，否则返回false</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Thread <span class="title">getOwner</span><span class="params">()</span><span class="comment">// 返回当前拥有此锁的线程，如果此锁不被任何线程拥有，则返回 null</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span><span class="comment">// 查询是否有线程正在等待获取此锁</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThread</span><span class="params">(Thread thread)</span><span class="comment">// 查询指定线程是否正在等待获取此锁</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getQueueLength</span><span class="params">()</span><span class="comment">// 返回正在等待获取此锁的线程估计数</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Collection&lt;Thread&gt; <span class="title">getQueuedThreads</span><span class="params">()</span><span class="comment">// 返回一个 collection，它包含可能正等待获取此锁的线程</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasWaiters</span><span class="params">(Condition condition)</span><span class="comment">// 查询是否有线程正在等待与此锁有关的指定条件</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWaitQueueLength</span><span class="params">(Condition condition)</span><span class="comment">// 返回正在等待与此锁相关的指定条件的线程估计数</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Collection&lt;Thread&gt; <span class="title">getWaitingThreads</span><span class="params">(Condition condition)</span><span class="comment">// 返回一个 collection，它包含可能正在等待与此锁相关指定条件的哪些线程</span></span></span><br></pre></td></tr></table></figure>



<h1 id="ReentrantLock-简单使用"><a href="#ReentrantLock-简单使用" class="headerlink" title="ReentrantLock 简单使用"></a>ReentrantLock 简单使用</h1><h2 id="lock-和-unlock"><a href="#lock-和-unlock" class="headerlink" title="lock() 和 unlock()"></a>lock() 和 unlock()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockOneTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">            lock.lock();<span class="comment">//获取锁</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"线程 【"</span>+Thread.currentThread().getName()+<span class="string">"】 进来了 获取到锁 开始"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() +(i+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"线程 【"</span>+Thread.currentThread().getName()+<span class="string">"】 释放锁 结束"</span>);</span><br><span class="line">            lock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> MyService myService;</span><br><span class="line"></span><br><span class="line">        MyThread(MyService myService)&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            <span class="keyword">this</span>.myService = myService;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            myService.testMethod();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyService service = <span class="keyword">new</span> MyService();</span><br><span class="line"></span><br><span class="line">        MyThread a1 = <span class="keyword">new</span> MyThread(service);</span><br><span class="line">        MyThread a2 = <span class="keyword">new</span> MyThread(service);</span><br><span class="line">        MyThread a3 = <span class="keyword">new</span> MyThread(service);</span><br><span class="line">        MyThread a4 = <span class="keyword">new</span> MyThread(service);</span><br><span class="line">        MyThread a5 = <span class="keyword">new</span> MyThread(service);</span><br><span class="line"></span><br><span class="line">        a1.setName(<span class="string">"a1==&gt;"</span>);</span><br><span class="line">        a1.start();</span><br><span class="line"></span><br><span class="line">        a2.setName(<span class="string">"a2==&gt;"</span>);</span><br><span class="line">        a2.start();</span><br><span class="line"></span><br><span class="line">        a3.setName(<span class="string">"a3==&gt;"</span>);</span><br><span class="line">        a3.start();</span><br><span class="line"></span><br><span class="line">        a4.setName(<span class="string">"a4==&gt;"</span>);</span><br><span class="line">        a4.start();</span><br><span class="line"></span><br><span class="line">        a5.setName(<span class="string">"a5==&gt;"</span>);</span><br><span class="line">        a5.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">线程 【a1&#x3D;&#x3D;&gt;】 进来了 获取到锁 开始</span><br><span class="line">a1&#x3D;&#x3D;&gt;1</span><br><span class="line">a1&#x3D;&#x3D;&gt;2</span><br><span class="line">a1&#x3D;&#x3D;&gt;3</span><br><span class="line">a1&#x3D;&#x3D;&gt;4</span><br><span class="line">线程 【a1&#x3D;&#x3D;&gt;】 释放锁 结束</span><br><span class="line">线程 【a2&#x3D;&#x3D;&gt;】 进来了 获取到锁 开始</span><br><span class="line">a2&#x3D;&#x3D;&gt;1</span><br><span class="line">a2&#x3D;&#x3D;&gt;2</span><br><span class="line">a2&#x3D;&#x3D;&gt;3</span><br><span class="line">a2&#x3D;&#x3D;&gt;4</span><br><span class="line">线程 【a2&#x3D;&#x3D;&gt;】 释放锁 结束</span><br><span class="line">线程 【a3&#x3D;&#x3D;&gt;】 进来了 获取到锁 开始</span><br><span class="line">a3&#x3D;&#x3D;&gt;1</span><br><span class="line">a3&#x3D;&#x3D;&gt;2</span><br><span class="line">a3&#x3D;&#x3D;&gt;3</span><br><span class="line">a3&#x3D;&#x3D;&gt;4</span><br><span class="line">线程 【a3&#x3D;&#x3D;&gt;】 释放锁 结束</span><br><span class="line">线程 【a4&#x3D;&#x3D;&gt;】 进来了 获取到锁 开始</span><br><span class="line">a4&#x3D;&#x3D;&gt;1</span><br><span class="line">a4&#x3D;&#x3D;&gt;2</span><br><span class="line">a4&#x3D;&#x3D;&gt;3</span><br><span class="line">a4&#x3D;&#x3D;&gt;4</span><br><span class="line">线程 【a4&#x3D;&#x3D;&gt;】 释放锁 结束</span><br><span class="line">线程 【a5&#x3D;&#x3D;&gt;】 进来了 获取到锁 开始</span><br><span class="line">a5&#x3D;&#x3D;&gt;1</span><br><span class="line">a5&#x3D;&#x3D;&gt;2</span><br><span class="line">a5&#x3D;&#x3D;&gt;3</span><br><span class="line">a5&#x3D;&#x3D;&gt;4</span><br><span class="line">线程 【a5&#x3D;&#x3D;&gt;】 释放锁 结束</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<h2 id="tryLock-方法"><a href="#tryLock-方法" class="headerlink" title="tryLock()方法"></a>tryLock()方法</h2><blockquote>
<p>在调用时,锁如果没有被另一个线程持有的情况下，才获取该锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTryLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceHandle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lock.tryLock()) &#123;</span><br><span class="line">                log.info(Thread.currentThread().getName() + <span class="string">"获取到锁 （🔒） "</span>);</span><br><span class="line">                Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.info(Thread.currentThread().getName() + <span class="string">"未获取到锁（🔒）"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lock.isHeldByCurrentThread()) &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLockTryLock reentrantLockTryLock = <span class="keyword">new</span> ReentrantLockTryLock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(reentrantLockTryLock::serviceHandle,<span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(reentrantLockTryLock::serviceHandle,<span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">00:33:58.045 [t2] INFO com.fengabner.lock.ReentrantLockTryLock - t2未获取到锁（🔒）</span><br><span class="line">00:33:58.045 [t1] INFO com.fengabner.lock.ReentrantLockTryLock - t1获取到锁 （🔒） </span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<h2 id="lockInterruptibly-方法"><a href="#lockInterruptibly-方法" class="headerlink" title="lockInterruptibly()方法"></a>lockInterruptibly()方法</h2><blockquote>
<p>中断等待获取锁的线程,如果当前线程未被中断,则去获取锁,已被中断则抛异常。</p>
<p>当两个线程同时通过lock.lockInterruptibly()获取某个锁时，假若此时线程A获取到了锁，而线程B只有等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockInterruptibly</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceHandle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">"thread &#123;&#125; get lock"</span>,Thread.currentThread().getName());</span><br><span class="line">            lock.lockInterruptibly();</span><br><span class="line"></span><br><span class="line">            log.info(<span class="string">"thread &#123;&#125; has lock"</span>,Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                log.info(<span class="string">"Thread &#123;&#125; do something...&#123;&#125;"</span>,Thread.currentThread().getName(),i);</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">"thread &#123;&#125; lock end"</span>,Thread.currentThread().getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">"thread &#123;&#125; 被中断"</span>,Thread.currentThread().getName());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lock.isHeldByCurrentThread()) &#123;<span class="comment">// 查询当前线程是否持有此锁</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">                log.info(<span class="string">"thread &#123;&#125; 释放锁"</span>,Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ReentrantLockInterruptibly reentrantLockInterruptibly = <span class="keyword">new</span> ReentrantLockInterruptibly();</span><br><span class="line">        <span class="keyword">new</span> Thread(reentrantLockInterruptibly::serviceHandle,<span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(reentrantLockInterruptibly::serviceHandle,<span class="string">"t2"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 如果线程t2没有得到锁，中断t2的等待</span></span><br><span class="line">        t2.interrupt();</span><br><span class="line">        log.info(<span class="string">"main end ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">23:44:02.148 [t1] INFO com.fengabner.lock.ReentrantLockInterruptibly - thread t1 get lock</span><br><span class="line">23:44:02.156 [t1] INFO com.fengabner.lock.ReentrantLockInterruptibly - thread t1 has lock</span><br><span class="line">23:44:02.249 [t2] INFO com.fengabner.lock.ReentrantLockInterruptibly - thread t2 get lock</span><br><span class="line">23:44:02.349 [main] INFO com.fengabner.lock.ReentrantLockInterruptibly - main end ...</span><br><span class="line">23:44:02.349 [t2] ERROR com.fengabner.lock.ReentrantLockInterruptibly - thread t2 被中断</span><br><span class="line">java.lang.InterruptedException</span><br><span class="line">	at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchronizer.java:898)</span><br><span class="line">	at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchronizer.java:1222)</span><br><span class="line">	at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:335)</span><br><span class="line">	at com.fengabner.lock.ReentrantLockInterruptibly.serviceHandle(ReentrantLockInterruptibly.java:21)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">23:44:03.158 [t1] INFO com.fengabner.lock.ReentrantLockInterruptibly - Thread t1 do something...0</span><br><span class="line">23:44:04.161 [t1] INFO com.fengabner.lock.ReentrantLockInterruptibly - Thread t1 do something...1</span><br><span class="line">23:44:05.163 [t1] INFO com.fengabner.lock.ReentrantLockInterruptibly - Thread t1 do something...2</span><br><span class="line">23:44:06.167 [t1] INFO com.fengabner.lock.ReentrantLockInterruptibly - Thread t1 do something...3</span><br><span class="line">23:44:07.170 [t1] INFO com.fengabner.lock.ReentrantLockInterruptibly - Thread t1 do something...4</span><br><span class="line">23:44:07.170 [t1] INFO com.fengabner.lock.ReentrantLockInterruptibly - thread t1 lock end</span><br><span class="line">23:44:07.170 [t1] INFO com.fengabner.lock.ReentrantLockInterruptibly - thread t1 释放锁</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<h2 id="getHoldCount"><a href="#getHoldCount" class="headerlink" title="getHoldCount()"></a>getHoldCount()</h2><blockquote>
<p>查询当前线程保持锁定的个数，也就是调用lock()方法的个数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockGetHoldCount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceHandle1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line"></span><br><span class="line">            log.info(<span class="string">"&#123;&#125; getHoldCount : &#123;&#125;"</span>,Thread.currentThread().getName(),lock.getHoldCount());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.serviceHandle2();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceHandle2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            log.info(<span class="string">"&#123;&#125; getHoldCount : &#123;&#125;"</span>,Thread.currentThread().getName(),lock.getHoldCount());</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLockGetHoldCount reentrantLockGetHoldCount = <span class="keyword">new</span> ReentrantLockGetHoldCount();</span><br><span class="line">        <span class="keyword">new</span> Thread(reentrantLockGetHoldCount::serviceHandle1,<span class="string">"t1"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">00:40:33.573 [t1] INFO com.fengabner.lock.ReentrantLockGetHoldCount - t1 getHoldCount : 1</span><br><span class="line">00:40:33.581 [t1] INFO com.fengabner.lock.ReentrantLockGetHoldCount - t1 getHoldCount : 2</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<h2 id="isHeldByCurrentThread"><a href="#isHeldByCurrentThread" class="headerlink" title="isHeldByCurrentThread()"></a>isHeldByCurrentThread()</h2><blockquote>
<p>查询当前线程是否持有此锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockIsHeldByCurrentThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">serviceHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">"当前线程&#123;&#125;是否持有锁 &#123;&#125;"</span>, Thread.currentThread().getName(), lock.isHeldByCurrentThread());</span><br><span class="line">            lock.lock();</span><br><span class="line">            log.info(<span class="string">"当前线程&#123;&#125;是否持有锁 &#123;&#125;"</span>, Thread.currentThread().getName(), lock.isHeldByCurrentThread());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            log.info(<span class="string">"当前线程&#123;&#125;释放了锁"</span>, Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLockIsHeldByCurrentThread reentrantLockIsHeldByCurrentThread = <span class="keyword">new</span> ReentrantLockIsHeldByCurrentThread();</span><br><span class="line">        <span class="keyword">new</span> Thread(reentrantLockIsHeldByCurrentThread::serviceHandle, <span class="string">"t1"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">11:45:24.377 [t1] INFO com.fengabner.lock.ReentrantLockIsHeldByCurrentThread - 当前线程t1是否持有锁 false</span><br><span class="line">11:45:24.384 [t1] INFO com.fengabner.lock.ReentrantLockIsHeldByCurrentThread - 当前线程t1是否持有锁 true</span><br><span class="line">11:45:24.384 [t1] INFO com.fengabner.lock.ReentrantLockIsHeldByCurrentThread - 当前线程t1释放了锁</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<h2 id="getWaitQueueLength-Condition-condition"><a href="#getWaitQueueLength-Condition-condition" class="headerlink" title="getWaitQueueLength(Condition condition)"></a>getWaitQueueLength(Condition condition)</h2><blockquote>
<p>返回正在等待与此锁相关的指定条件的线程估计数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockGetWaitQueueLength</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">public</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceWaitHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            condition.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceSignalHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            log.info(<span class="string">"当前有&#123;&#125;个正在等待 condition"</span>, lock.getWaitQueueLength(condition));</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ReentrantLockGetWaitQueueLength lockGetWaitQueueLength = <span class="keyword">new</span> ReentrantLockGetWaitQueueLength();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(lockGetWaitQueueLength::serviceWaitHandle).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(lockGetWaitQueueLength::serviceSignalHandle).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">15:30:30.508 [Thread-10] INFO com.fengabner.lock.ReentrantLockGetWaitQueueLength - 当前有10个正在等待 condition</span><br><span class="line">15:30:30.525 [Thread-11] INFO com.fengabner.lock.ReentrantLockGetWaitQueueLength - 当前有9个正在等待 condition</span><br><span class="line">15:30:30.527 [Thread-12] INFO com.fengabner.lock.ReentrantLockGetWaitQueueLength - 当前有8个正在等待 condition</span><br><span class="line">15:30:30.527 [Thread-13] INFO com.fengabner.lock.ReentrantLockGetWaitQueueLength - 当前有7个正在等待 condition</span><br><span class="line">15:30:30.528 [Thread-14] INFO com.fengabner.lock.ReentrantLockGetWaitQueueLength - 当前有6个正在等待 condition</span><br><span class="line">15:30:30.529 [Thread-15] INFO com.fengabner.lock.ReentrantLockGetWaitQueueLength - 当前有5个正在等待 condition</span><br><span class="line">15:30:30.529 [Thread-16] INFO com.fengabner.lock.ReentrantLockGetWaitQueueLength - 当前有4个正在等待 condition</span><br><span class="line">15:30:30.529 [Thread-17] INFO com.fengabner.lock.ReentrantLockGetWaitQueueLength - 当前有3个正在等待 condition</span><br><span class="line">15:30:30.530 [Thread-18] INFO com.fengabner.lock.ReentrantLockGetWaitQueueLength - 当前有2个正在等待 condition</span><br><span class="line">15:30:30.530 [Thread-19] INFO com.fengabner.lock.ReentrantLockGetWaitQueueLength - 当前有1个正在等待 condition</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java 并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>java并发之wait和notify</title>
    <url>/2020/06/27/java%E5%B9%B6%E5%8F%91%E4%B9%8Bwait%E5%92%8Cnotify/</url>
    <content><![CDATA[<h1 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h1><ul>
<li>obj.wait() 让进入 object 监视器的线程到 waitSet 等待，注意必须是获得对象锁的像锁的线程才能调用。wait方法会释放对象的锁，进入 WaitSet 等待区，从而让其他线程就机会获取对象的锁。无限制等待，直到 notify 为止。</li>
<li>obj.wait(long n) 有时限的等待, 到 n 毫秒后结束等待，或是被 notify。</li>
<li>obj.notify() 在 object 上正在 waitSet 等待的线程中挑一个唤醒。</li>
<li>obj.notifyAll() 让 object 上正在 waitSet 等待的线程全部唤醒。</li>
</ul>
<a id="more"></a>

<p><strong>简单示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyTwoTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                log.debug(<span class="string">"执行...."</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    obj.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">"do something...."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"t1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                log.debug(<span class="string">"执行...."</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    obj.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">"do something...."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"t2"</span>).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        log.debug(<span class="string">"唤醒 obj 上其它等待线程"</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            obj.notify(); <span class="comment">// 随机唤醒obj上的一个等待线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 notify()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10:38:24.631 [t1] DEBUG com.fengabner.business.WaitNotifyTwoTest - 执行....</span><br><span class="line">10:38:24.638 [t2] DEBUG com.fengabner.business.WaitNotifyTwoTest - 执行....</span><br><span class="line">10:38:26.638 [main] DEBUG com.fengabner.business.WaitNotifyTwoTest - 唤醒 obj 上其它等待线程</span><br><span class="line">10:38:26.638 [t1] DEBUG com.fengabner.business.WaitNotifyTwoTest - do something....</span><br></pre></td></tr></table></figure>

<p>使用 notifyAll()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10:39:09.904 [t1] DEBUG com.fengabner.business.WaitNotifyTwoTest - 执行....</span><br><span class="line">10:39:09.911 [t2] DEBUG com.fengabner.business.WaitNotifyTwoTest - 执行....</span><br><span class="line">10:39:11.912 [main] DEBUG com.fengabner.business.WaitNotifyTwoTest - 唤醒 obj 上其它等待线程</span><br><span class="line">10:39:11.912 [t2] DEBUG com.fengabner.business.WaitNotifyTwoTest - do something....</span><br><span class="line">10:39:11.912 [t1] DEBUG com.fengabner.business.WaitNotifyTwoTest - do something....</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong></p>
<ul>
<li><p>wait()、notify/notifyAll() 方法是Object的本地final方法，无法被重写。</p>
</li>
<li><p>wait()、notify/notifyAll() 需要配合 synchronized 关键字使用</p>
</li>
<li><p>当线程执行wait()方法时候，会释放当前的锁，然后让出CPU，进入等待状态。</p>
</li>
<li><p>notify/notifyAll() 的执行只是唤醒沉睡的线程，而不会立即释放锁，锁的释放要看代码块的具体执行情况。</p>
</li>
<li><p>notify方法只唤醒一个等待（对象的）线程并使该线程开始执行，notifyAll 会唤醒所有等待(对象的)线程。</p>
</li>
<li><p>使用if 还是while</p>
<ul>
<li>notify唤醒沉睡的线程后，线程会接着上次的执行继续往下执行。所以在进行条件判断时候，可以先把 wait 语句忽略不计来进行考虑；显然，要确保程序一定要执行，并且要保证程序直到满足一定的条件再执行，要使用while进行等待，直到满足条件才继续往下执行。</li>
</ul>
<h1 id="wait-notify原理"><a href="#wait-notify原理" class="headerlink" title="wait/notify原理"></a>wait/notify原理</h1></li>
</ul>
<p><img src="/.com//image-20200627105711596.png" alt="image-20200627105711596"></p>
<ul>
<li>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态</li>
<li>WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入 EntryList 重新竞争</li>
<li>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片</li>
<li>BLOCKED 线程会在 Owner 线程释放锁时唤醒</li>
</ul>
<h1 id="wait和sleep比较"><a href="#wait和sleep比较" class="headerlink" title="wait和sleep比较"></a>wait和sleep比较</h1><ul>
<li>它们 状态都是 TIMED_WAITING。</li>
<li>sleep 是 Thread 方法，而 wait 是 Object 的方法。</li>
<li>sleep 不需要强制和 synchronized 配合使用，但 wait 需要 和 synchronized 一起用。</li>
<li>sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁。</li>
</ul>
<h1 id="同步设计模式之保护性暂停"><a href="#同步设计模式之保护性暂停" class="headerlink" title="同步设计模式之保护性暂停"></a>同步设计模式之保护性暂停</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><img src="/.com//image-20200627111642813.png" alt="image-20200627111642813"></p>
<p>保护性暂停即 Guarded Suspension，用在一个线程等待另一个线程的执行结果。</p>
<ul>
<li>有一个结果需要从一个线程传递到另一个线程，让他们关联同一个 GuardedObject</li>
<li>如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者/消费者）</li>
<li>JDK 中，join 的实现、Future 的实现，采用的就是此模式</li>
<li>因为要等待另一方的结果，因此属于同步模式</li>
</ul>
<h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuardedObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (response == <span class="keyword">null</span>) &#123; <span class="comment">//防止虚假唤醒</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">(Object response)</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.response = response;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Downloader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">download</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        HttpURLConnection connection = (HttpURLConnection) <span class="keyword">new</span> URL(<span class="string">"https://www.baidu.com/"</span>).openConnection();</span><br><span class="line">        List&lt;String&gt; lines = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span>(BufferedReader reader =</span><br><span class="line">                    <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8))) &#123;</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line =reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                lines.add(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lines;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GuardedObject guardedObject = <span class="keyword">new</span> GuardedObject();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">"开始获取数据"</span>);</span><br><span class="line">            List&lt;String&gt; list = (List&lt;String&gt;) guardedObject.get();</span><br><span class="line"></span><br><span class="line">            log.debug(<span class="string">"数据的大小为：&#123;&#125;"</span>, list.size());</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">"下载数据"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                List&lt;String&gt; list = Downloader.download();</span><br><span class="line">                guardedObject.complete(list);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12:39:41.456 [t1] DEBUG com.fengabner.guarded.Test - 开始获取数据</span><br><span class="line">12:39:41.465 [t2] DEBUG com.fengabner.guarded.Test - 下载数据</span><br><span class="line">12:39:42.624 [t1] DEBUG com.fengabner.guarded.Test - 数据的大小为：3</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<h2 id="带有超时效果的保护性暂停"><a href="#带有超时效果的保护性暂停" class="headerlink" title="带有超时效果的保护性暂停"></a>带有超时效果的保护性暂停</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuardedObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout)</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="comment">//开始时间</span></span><br><span class="line">            <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">            <span class="comment">//所经历的时间</span></span><br><span class="line">            <span class="keyword">long</span> passedTime = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (response == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//这一轮循环需要等待的时间</span></span><br><span class="line">                <span class="keyword">long</span> waitTime = timeout - passedTime;</span><br><span class="line">                <span class="keyword">if</span>(waitTime &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//等待唤醒</span></span><br><span class="line">                    <span class="keyword">this</span>.wait(waitTime);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//真实经历的时间</span></span><br><span class="line">                passedTime = System.currentTimeMillis() - begin;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">(Object response)</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.response = response;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="join-原理"><a href="#join-原理" class="headerlink" title="join 原理"></a>join 原理</h2><p>join 底层实现其实就是用的wait，使用了带有超时效果的保护性暂停。</p>
<p>join源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    join(<span class="number">0</span>);<span class="comment">//当超时时间 millis == 0时，表示一直等待，没有超时时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  			<span class="comment">//如果 == 0，表示不设置超时时间，一直等待</span></span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;<span class="comment">//判断线程是否存活</span></span><br><span class="line">                wait(<span class="number">0</span>);<span class="comment">//一直等待</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;<span class="comment">//判断线程是否存活</span></span><br><span class="line">                <span class="keyword">long</span> delay = millis - now;<span class="comment">//计算延迟时间</span></span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;<span class="comment">//如果延迟时间&lt;=0,退出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);<span class="comment">//等待 计算的delay时间</span></span><br><span class="line">                now = System.currentTimeMillis() - base;<span class="comment">//已经经过的时间</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="同步设计模式之保护性暂停扩展"><a href="#同步设计模式之保护性暂停扩展" class="headerlink" title="同步设计模式之保护性暂停扩展"></a>同步设计模式之保护性暂停扩展</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p><strong>多任务版 GuardedObject</strong></p>
<p><img src="/.com//image-20200627151330997.png" alt="image-20200627151330997"></p>
<p><strong>分析</strong>：如果需要在多个类之间使用 GuardedObject 对象，作为参数传递不是很方便，因此设计一个用来解耦的中间类， 这样不仅能够解耦【结果等待者】和【结果生产者】，还能够同时支持多个任务的管理。</p>
<h2 id="简单实现-1"><a href="#简单实现-1" class="headerlink" title="简单实现"></a>简单实现</h2><p>新增 id 用来标识 GuardedObject</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuardedObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//多个GuardedObject时用于标识</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GuardedObject</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (response == <span class="keyword">null</span>) &#123; <span class="comment">//防止虚假唤醒</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout)</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="comment">//开始时间</span></span><br><span class="line">            <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">            <span class="comment">//所经历的时间</span></span><br><span class="line">            <span class="keyword">long</span> passedTime = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (response == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//这一轮循环需要等待的时间</span></span><br><span class="line">                <span class="keyword">long</span> waitTime = timeout - passedTime;</span><br><span class="line">                <span class="keyword">if</span>(waitTime &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//等待唤醒</span></span><br><span class="line">                    <span class="keyword">this</span>.wait(waitTime);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//真实经历的时间</span></span><br><span class="line">                passedTime = System.currentTimeMillis() - begin;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">(Object response)</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.response = response;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中间解耦类：使用线程安全的Map来存储GuardedObject，用于解耦。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MailBoxes</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, GuardedObject&gt; map = <span class="keyword">new</span> Hashtable();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成唯一id</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">generateId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成GuardedObject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GuardedObject <span class="title">createGuardedObject</span><span class="params">()</span></span>&#123;</span><br><span class="line">        GuardedObject go = <span class="keyword">new</span> GuardedObject(generateId());</span><br><span class="line">        map.put(go.getId(), go);</span><br><span class="line">        <span class="keyword">return</span> go;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GuardedObject <span class="title">getGuardedObject</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.remove(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Integer&gt; <span class="title">getIds</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.keySet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>业务相关，收信与送信</p>
<p><strong>收信人</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        GuardedObject guardedObject = MailBoxes.createGuardedObject();</span><br><span class="line">        log.debug(<span class="string">"开始收信了... id:&#123;&#125;"</span>,guardedObject.getId());</span><br><span class="line"></span><br><span class="line">        Object mail = guardedObject.get(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">"收到信了... id:&#123;&#125;, 内容:&#123;&#125;"</span>,guardedObject.getId(),mail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>送信人</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Postman</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String mail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Postman</span><span class="params">(<span class="keyword">int</span> id, String mail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.mail = mail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        GuardedObject guardedObject = MailBoxes.getGuardedObject(id);</span><br><span class="line">        log.debug(<span class="string">"开始送信了... id:&#123;&#125;, 内容:&#123;&#125;"</span>,id,mail);</span><br><span class="line">        guardedObject.complete(mail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> People());</span><br><span class="line">            thread.setName(<span class="string">"p"</span>+i);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> id: MailBoxes.getIds()) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Postman(id,<span class="string">"这是内容项"</span>+id));</span><br><span class="line">            thread.setName(<span class="string">"m"</span>+id);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15:10:48.405 [p2] DEBUG com.fengabner.guarded.People - 开始收信了... id:3</span><br><span class="line">15:10:48.405 [p1] DEBUG com.fengabner.guarded.People - 开始收信了... id:1</span><br><span class="line">15:10:48.405 [p0] DEBUG com.fengabner.guarded.People - 开始收信了... id:2</span><br><span class="line">15:10:51.407 [m3] DEBUG com.fengabner.guarded.Postman - 开始送信了... id:3, 内容:这是内容项3</span><br><span class="line">15:10:51.407 [p2] DEBUG com.fengabner.guarded.People - 收到信了... id:3, 内容:这是内容项3</span><br><span class="line">15:10:51.407 [m2] DEBUG com.fengabner.guarded.Postman - 开始送信了... id:2, 内容:这是内容项2</span><br><span class="line">15:10:51.408 [p0] DEBUG com.fengabner.guarded.People - 收到信了... id:2, 内容:这是内容项2</span><br><span class="line">15:10:51.408 [m1] DEBUG com.fengabner.guarded.Postman - 开始送信了... id:1, 内容:这是内容项1</span><br><span class="line">15:10:51.408 [p1] DEBUG com.fengabner.guarded.People - 收到信了... id:1, 内容:这是内容项1</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<h1 id="同步模式之顺序控制"><a href="#同步模式之顺序控制" class="headerlink" title="同步模式之顺序控制"></a>同步模式之顺序控制</h1><h2 id="固定顺序运行"><a href="#固定顺序运行" class="headerlink" title="固定顺序运行"></a>固定顺序运行</h2><p>例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyThreeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来同步的对象</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">// t2 运行标记， 代表 t2 是否执行过</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> t2Runed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                <span class="comment">// 如果 t2 没有执行过</span></span><br><span class="line">                <span class="keyword">while</span> (!t2Runed) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// t1 先等一会</span></span><br><span class="line">                        obj.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">"1"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">"2"</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                <span class="comment">//修改运行标记</span></span><br><span class="line">                t2Runed = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 通知 obj 上等待的线程（可能有多个，因此需要用 notifyAll）</span></span><br><span class="line">                obj.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">23:40:25.968 [Thread-1] DEBUG com.fengabner.business.WaitNotifyThreeTest - 2</span><br><span class="line">23:40:25.973 [Thread-0] DEBUG com.fengabner.business.WaitNotifyThreeTest - 1</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>



<p>缺点：</p>
<ul>
<li><p>需要保证先 wait 再 notify，否则 wait 线程永远得不到唤醒。因此使用了『运行标记』来判断该不该 wait。</p>
</li>
<li><p>如果有些干扰线程错误地 notify 了 wait 线程，条件不满足时还要重新等待，使用了 while 循环来解决 此问题。</p>
</li>
<li><p>唤醒对象上的 wait 线程需要使用 notifyAll，因为『同步对象』上的等待线程可能不止一个。</p>
</li>
</ul>
<p>因此使用 park unpack 更加灵活。</p>
<h2 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h2><p>例子：交替打印 abc</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fengabner.business;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: fengabner</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/7/1 23:32</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyFourTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> flag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> loopNums;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WaitNotifyFourTest</span><span class="params">(<span class="keyword">int</span> flag, <span class="keyword">int</span> loopNums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">        <span class="keyword">this</span>.loopNums = loopNums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String message, <span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNums; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">this</span>.flag != flag) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(message);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.flag = (flag + <span class="number">1</span>) % <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">this</span>.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WaitNotifyFourTest waitNotifyFourTest = <span class="keyword">new</span> WaitNotifyFourTest(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; waitNotifyFourTest.print(<span class="string">"a"</span>, <span class="number">0</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; waitNotifyFourTest.print(<span class="string">"b"</span>, <span class="number">1</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; waitNotifyFourTest.print(<span class="string">"c"</span>, <span class="number">2</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abcabcabcabcabcabcabcabcabcabc</span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>



<p><strong>参考资料</strong></p>
<p><a href="https://www.bilibili.com/video/BV16J411h7Rd" target="_blank" rel="noopener">全面深入了解并发编程</a></p>
<p>【java并发编程之美】</p>
]]></content>
      <categories>
        <category>java 并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>java并发基础</title>
    <url>/2020/06/24/java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="进程线程的概念"><a href="#进程线程的概念" class="headerlink" title="进程线程的概念"></a>进程线程的概念</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的 。</p>
<p>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 进程就可以视为程序的一个实例。</p>
<a id="more"></a>

<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>一个进程之内可以分为一到多个线程。 </p>
<p>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行</p>
<p>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作 为线程的容器</p>
<h2 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h2><ul>
<li><p>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集 </p>
</li>
<li><p>进程拥有共享的资源，如内存空间等，供其内部的线程共享</p>
</li>
<li><p>进程间通信较为复杂</p>
<ul>
<li>同一台计算机的进程通信称为 IPC(Inter-process communication) </li>
<li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP</li>
</ul>
</li>
<li><p>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量</p>
</li>
<li><p>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</p>
</li>
</ul>
<h1 id="并发并行的概念"><a href="#并发并行的概念" class="headerlink" title="并发并行的概念"></a>并发并行的概念</h1><p><strong>并行:</strong> 指两个或多个事件在同一时刻点发生</p>
<p><strong>并发:</strong> 指两个或多个事件在同一时间段内发生</p>
<h1 id="Java-创建线程方式"><a href="#Java-创建线程方式" class="headerlink" title="Java 创建线程方式"></a>Java 创建线程方式</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadStartMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UseThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            log.info(<span class="string">"我是通过继承Thread方式启动的"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UseRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            log.info(<span class="string">"我是通过实现Runnable方式启动的"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UseCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            log.info(<span class="string">"我是通过实现Callable方式启动的,具备返回值"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"this is callable"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        UseThread useThread = <span class="keyword">new</span> UseThread();</span><br><span class="line">        <span class="keyword">new</span> Thread(useThread).start();</span><br><span class="line"></span><br><span class="line">        UseRunnable useRunnable = <span class="keyword">new</span> UseRunnable();</span><br><span class="line">        <span class="keyword">new</span> Thread(useRunnable).start();</span><br><span class="line"></span><br><span class="line">        UseCallable useCallable = <span class="keyword">new</span> UseCallable();</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;String&gt;(useCallable);</span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//get 方法阻塞</span></span><br><span class="line">        log.info(futureTask.get());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">16:59:16.970 [Thread-3] INFO com.fengabner.business.ThreadStartMethod - 我是通过实现Callable方式启动的,具备返回值</span><br><span class="line">16:59:16.970 [Thread-2] INFO com.fengabner.business.ThreadStartMethod - 我是通过实现Runnable方式启动的</span><br><span class="line">16:59:16.970 [Thread-1] INFO com.fengabner.business.ThreadStartMethod - 我是通过继承Thread方式启动的</span><br><span class="line">16:59:19.970 [main] INFO com.fengabner.business.ThreadStartMethod - this is callable</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>



<h1 id="Java-线程状态"><a href="#Java-线程状态" class="headerlink" title="Java 线程状态"></a>Java 线程状态</h1><p><img src="/.com//image-20200620231936167.png" alt="image-20200620231936167"></p>
<p>代码测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="string">"t1"</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                log.debug(<span class="string">"running..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="string">"t2"</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>) &#123; </span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(<span class="string">"t3"</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                log.debug(<span class="string">"running..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">        Thread t4 = <span class="keyword">new</span> Thread(<span class="string">"t4"</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (ThreadState<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000000</span>); </span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t4.start();</span><br><span class="line"></span><br><span class="line">        Thread t5 = <span class="keyword">new</span> Thread(<span class="string">"t5"</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t2.join(); </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t5.start();</span><br><span class="line"></span><br><span class="line">        Thread t6 = <span class="keyword">new</span> Thread(<span class="string">"t6"</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (ThreadState<span class="class">.<span class="keyword">class</span>) </span>&#123; </span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t6.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">"t1 state &#123;&#125;"</span>, t1.getState());</span><br><span class="line">        log.debug(<span class="string">"t2 state &#123;&#125;"</span>, t2.getState());</span><br><span class="line">        log.debug(<span class="string">"t3 state &#123;&#125;"</span>, t3.getState());</span><br><span class="line">        log.debug(<span class="string">"t4 state &#123;&#125;"</span>, t4.getState());</span><br><span class="line">        log.debug(<span class="string">"t5 state &#123;&#125;"</span>, t5.getState());</span><br><span class="line">        log.debug(<span class="string">"t6 state &#123;&#125;"</span>, t6.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">23:11:18.172 [thread3] DEBUG com.fengabner.business.ThreadState - running...</span><br><span class="line">23:11:18.808 [main] DEBUG com.fengabner.business.ThreadState - t1 state NEW</span><br><span class="line">23:11:18.811 [main] DEBUG com.fengabner.business.ThreadState - t2 state RUNNABLE</span><br><span class="line">23:11:18.811 [main] DEBUG com.fengabner.business.ThreadState - t3 state TERMINATED</span><br><span class="line">23:11:18.811 [main] DEBUG com.fengabner.business.ThreadState - t4 state TIMED_WAITING</span><br><span class="line">23:11:18.811 [main] DEBUG com.fengabner.business.ThreadState - t5 state WAITING</span><br><span class="line">23:11:18.811 [main] DEBUG com.fengabner.business.ThreadState - t6 state BLOCKED</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>初始(NEW)</strong>：新创建了一个线程对象，但还没有调用start()方法。</li>
<li><strong>运行(RUNNABLE)</strong>：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。<br>线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。</li>
<li><strong>阻塞(BLOCKED)</strong>：表示线程阻塞于锁。</li>
<li><strong>等待(WAITING)</strong>：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</li>
<li><strong>超时等待(TIMED_WAITING)</strong>：该状态不同于WAITING，它可以在指定的时间后自行返回。</li>
<li><strong>终止(TERMINATED)</strong>：表示该线程已经执行完毕。</li>
</ul>
<p><strong>重新理解</strong></p>
<p>1、<strong>NEW–&gt;RUNABLE</strong></p>
<ul>
<li>当调用 t.start()方法时，由 NEW –&gt; RUNNABLE</li>
</ul>
<p>2、<strong>RUNABL&lt;–&gt;WATING</strong></p>
<p>t 线程用 synchronized(obj) 获取了对象锁后</p>
<ul>
<li>调用 obj.wait()方法时，t 线程从RUNNABLE –&gt; WAITING</li>
<li>调用 obj.notify()，obj.notifyAll()，t.interrupt()时<ul>
<li>如果竞争失败，t 线程从 WAITING –&gt; RUNNABLE，线程进入Monitor中EntryList</li>
<li>如果竞争成功，t 线程从 WAITING –&gt; BLOCKED，Monitor中Owner指向该线程</li>
</ul>
</li>
</ul>
<p>3、<strong>RUNNABLE &lt;–&gt; WAITING</strong></p>
<ul>
<li>当前线程调用t.join()方法时，当前线程从 RUNNABLE –&gt; WAITING<ul>
<li>注意是当前线程在t 线程对象的监视器上等待</li>
</ul>
</li>
<li>t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 WAITING –&gt; RUNNABLE</li>
</ul>
<p>4、<strong>RUNNABLE &lt;–&gt; WAITING</strong></p>
<ul>
<li>当前线程调用LockSupport.park()方法会让当前线程从 RUNNABLE –&gt; WAITING</li>
<li>调用 LockSupport.unpark(目标线程)或调用了线程 的interrupt()，会让目标线程从 WAITING –&gt; RUNNABLE</li>
</ul>
<p>5、<strong>RUNNABLE &lt;–&gt; TIMED_WAITING</strong></p>
<p>t 线程用 synchronized(obj)获取了对象锁后</p>
<ul>
<li>调用 obj.wait(long n)方法时，t 线程从 RUNNABLE –&gt; TIMED_WAITING</li>
<li>t 线程等待时间超过了 n 毫秒，或调用 obj.notify()， obj.notifyAll()， t.interrupt()时<ul>
<li>竞争锁成功，t 线程从 TIMED_WAITING –&gt; RUNNABLE</li>
<li>竞争锁失败，t 线程从 TIMED_WAITING –&gt; BLOCKED</li>
</ul>
</li>
</ul>
<p>6、 <strong>RUNNABLE &lt;–&gt; TIMED_WAITING</strong></p>
<ul>
<li>当前线程调用t.join(long n)方法时，当前线程从 RUNNABLE –&gt; TIMED_WAITING<ul>
<li>注意是当前线程在t 线程对象的监视器上等待</li>
</ul>
</li>
<li>当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的interrupt() 时，当前线程从 TIMED_WAITING –&gt; RUNNABLE</li>
</ul>
<p>7、<strong>RUNNABLE &lt;–&gt; TIMED_WAITING</strong></p>
<ul>
<li><p>当前线程调用 Thread.sleep(long n) ，当前线程从 RUNNABLE –&gt; TIMED_WAITING</p>
</li>
<li><p>当前线程等待时间超过了 n 毫秒，当前线程从 TIMED_WAITING –&gt; RUNNABLE</p>
</li>
</ul>
<p>8、<strong>RUNNABLE &lt;–&gt; TIMED_WAITING</strong></p>
<ul>
<li>当前线程调用 LockSupport.parkNanos(long nanos)或 LockSupport.parkUntil(long millis)时，当前线程从 RUNNABLE –&gt; TIMED_WAITING</li>
<li>调用LockSupport.unpark(目标线程)或调用了线程 的 interrupt()，或是等待超时，会让目标线程从 TIMED_WAITING–&gt; RUNNABLE</li>
</ul>
<p>9、 <strong>RUNNABLE &lt;–&gt; BLOCKED</strong></p>
<ul>
<li>t 线程用 synchronized(obj) 获取了对象锁时如果竞争失败，从 RUNNABLE –&gt; BLOCKED</li>
<li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争 成功，从 BLOCKED –&gt; RUNNABLE，其它失败的线程仍然 BLOCKED</li>
</ul>
<p>10、<strong>RUNNABLE &lt;–&gt; TERMINATED</strong></p>
<ul>
<li>当前线程所有代码运行完毕，进入 TERMINATED</li>
</ul>
<h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>Sleep 不会释放锁</p>
<blockquote>
<p>java并发编程之美</p>
</blockquote>
<p>Thread 类中有一个静态的 sleep 方法，当一个执行中的线程调用了 Thread 的 sleep 方法后，调用线程会暂时让出指定时间的执行权，也就是在这期间不参与 CPU 的调度，但是该线程所拥有的监视器资源，比如锁还是持有不让出的。指定的睡眠时间到了后该函数就会正常返回，线程就处于就绪状态，然后参与 CPU 调度，获取到 CPU 资源后就可以继续执行了。如果在睡眠期间其他线程调用了该线程的 interrupt() 方法中断了该线程，则该线程会在调用 sleep方法的地方抛出 InterruptedException() 异常而返回。</p>
<p>线程在睡眠时拥有的监视器资源不会被释放：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个独占锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建线程A</span></span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//获取独占锁</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.info(<span class="string">"child threadA is in sleep......"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                log.info(<span class="string">"child threadA is in awaked......"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//释放锁</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建线程 B</span></span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//获取独占锁</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.info(<span class="string">"child threadB is in sleep......"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                log.info(<span class="string">"child threadB is in awaked......"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//释放锁</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">17:20:59.202 [Thread-0] INFO com.fengabner.business.SleepTest - child threadA is in sleep......</span><br><span class="line">17:21:00.205 [Thread-0] INFO com.fengabner.business.SleepTest - child threadA is in awaked......</span><br><span class="line">17:21:00.205 [Thread-1] INFO com.fengabner.business.SleepTest - child threadB is in sleep......</span><br><span class="line">17:21:01.205 [Thread-1] INFO com.fengabner.business.SleepTest - child threadB is in awaked......</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<p>当一个线程处于睡眠状态时，如果另外一个线程中断了它，会在调用 sleep 方法出抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepInterruptTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//创建线程</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.info(<span class="string">"child thread is in sleep......"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                log.info(<span class="string">"child thread is in awaked......"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//主线程休眠2s</span></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//主线程中断子线程</span></span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">17:24:03.522 [Thread-0] INFO com.fengabner.business.SleepInterruptTest - child thread is in sleep......</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">	at java.lang.Thread.sleep(Native Method)</span><br><span class="line">	at com.fengabner.business.SleepInterruptTest.lambda$main$0(SleepInterruptTest.java:18)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>



<h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><blockquote>
<p>java并发编程之美</p>
</blockquote>
<p>当一个线程调用 yield 方法时，当前线程会让出CPU使用权，然后处于 <strong>就绪状态</strong>，线程调度器会从线程就绪队列里面获取一个线程优先级最高的线程，当然也有可能会调度到刚刚让出 CPU 的那个线程来获取 CPU 的执行权。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YieldTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    YieldTest(String name)&#123;</span><br><span class="line">        <span class="comment">//创建并启动线程</span></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">this</span>);</span><br><span class="line">        t.setName(name);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//当 i=0 是让出 CPU 执行权，放弃时间片，并进行下一轮调度</span></span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                log.debug(Thread.currentThread().getName() + <span class="string">" yield cpu ..."</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//当前线程让出 cpu 执行权，放弃时间片，进行下一轮调度</span></span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.debug(Thread.currentThread().getName() + <span class="string">" is over..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> YieldTest(<span class="string">"t1"</span>);</span><br><span class="line">        <span class="keyword">new</span> YieldTest(<span class="string">"t2"</span>);</span><br><span class="line">        <span class="keyword">new</span> YieldTest(<span class="string">"t3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">16:55:01.648 [t1] DEBUG com.fengabner.business.YieldTest - t1 yield cpu ...</span><br><span class="line">16:55:01.648 [t3] DEBUG com.fengabner.business.YieldTest - t3 yield cpu ...</span><br><span class="line">16:55:01.650 [t1] DEBUG com.fengabner.business.YieldTest - t1 is over...</span><br><span class="line">16:55:01.648 [t2] DEBUG com.fengabner.business.YieldTest - t2 yield cpu ...</span><br><span class="line">16:55:01.651 [t2] DEBUG com.fengabner.business.YieldTest - t2 is over...</span><br><span class="line">16:55:01.651 [t3] DEBUG com.fengabner.business.YieldTest - t3 is over...</span><br></pre></td></tr></table></figure>

<h3 id="sleep与yield的区别"><a href="#sleep与yield的区别" class="headerlink" title="sleep与yield的区别"></a>sleep与yield的区别</h3><ul>
<li>当线程调用 sleep 方法时，调用线程会被阻塞挂起指定时间，在这期间线程调度器不会调度该线程。</li>
<li>调用 yield 方法时，线程只会让出自己剩余的时间片，并没有被阻塞挂起，而是处于就绪状态，线程调度器下一次调度时就有可能调度到当前线程执行。</li>
</ul>
<h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p>join() 功能说明：等待线程运行结束。（白话：谁调用join，就等待谁结束再进行运行）</p>
<p>备注：join底层实现原理就是wait</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinOneTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> secondValue = (<span class="keyword">int</span>) (Math.random() * <span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">            log.info(Thread.currentThread().getName()+<span class="string">" 计算的结果值为 ===&gt;"</span>+secondValue);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(secondValue);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.setName(<span class="string">"计算线程"</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">"当前线程"</span>+Thread.currentThread().getName()+<span class="string">"===&gt;我想等 计算线程 执行完毕后我再执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">21</span>:<span class="number">48</span>:<span class="number">26.324</span> [计算线程] INFO com.fengabner.business.JoinOneTest - 计算线程 计算的结果值为 ===&gt;<span class="number">3380</span></span><br><span class="line"><span class="number">21</span>:<span class="number">48</span>:<span class="number">29.719</span> [main] INFO com.fengabner.business.JoinOneTest - 当前线程main===&gt;我想等 计算线程 执行完毕后我再执行</span><br></pre></td></tr></table></figure>



<h2 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h2><p><strong>interrupt()</strong> ：中断线程。</p>
<ul>
<li><p>本线程中断自身是被允许的，且”中断标记”设置为true</p>
</li>
<li><p>其它线程调用本线程的interrupt()方法时，会通过 checkAccess() 检查权限。这有可能抛出 SecurityException 异常。</p>
<ul>
<li>如果线程在阻塞状态<strong>（调用线程的wait(), wait(long)或wait(long, int)会让它进入等待(阻塞)状态，或者调用线程的join(), join(long), join(long, int), sleep(long), sleep(long, int)也会让它进入阻塞状态）</strong>，调用了它的interrupt()方法，那么它的“中断状态”会被清除并且会收到一个InterruptedException异常<ul>
<li>例如：线程通过wait()进入阻塞状态，此时通过interrupt()中断该线程；调用interrupt()会立即将线程的中断标记设为“true”，但是由于线程处于阻塞状态，所以该“中断标记”会立即被清除为“false”，同时，会产生一个InterruptedException的异常。</li>
</ul>
</li>
<li>如果线程被阻塞在一个<strong>Selector</strong>选择器中，那么通过interrupt()中断它时；线程的中断标记会被设置为true，并且它会立即从选择操作中返回。</li>
<li>如果线程<strong>正在运行中</strong>，那么通过interrupt()中断线程时，它的中断标记会被设置为“true”。中断一个“已终止的线程”不会产生任何操作，这通常使用于使用isInterrupted做开关判断的死循环中。</li>
</ul>
</li>
</ul>
<blockquote>
<p>java并发编程之美解释：</p>
<p>当线程 A 运行时，线程 B 可以调用钱程 A的 interrupt（） 方法来设置线程 A 的中断标志为 true 并立即返回。设置标志仅仅是设置标志 ， 线程 A 实际并没有被中断， 它会继续往下执行 。 如果线程 A 因为调用了wait 系列函数、 join 方法或者 sleep 方法而被阻塞挂起，这时候若线程 B 调用线程A 的 interrupt（） 方法，线程 A 会在调用这些方法 的地方抛 出 InterruptedException 异常而返回。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">            checkAccess();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">            Interruptible b = blocker;</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">                interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">                b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        interrupt0();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>isInterrupted()</strong> : 检查<strong>此线程</strong>是否被中断，不会清除线程的中断状态</p>
<p><strong>interrupted()</strong> ：判断的是<strong>当前线程</strong>是否处于中断状态。是类的静态方法，同时会清除线程的中断状态。</p>
<p>线程正在运行中 根据中断标志位判断线程是否终止例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptTest3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() +<span class="string">"未终止..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() +<span class="string">"已终止"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        t.setName(<span class="string">"t"</span>);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"main thread interrupt t"</span>);</span><br><span class="line">        t.interrupt();</span><br><span class="line"></span><br><span class="line">        t.join();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">"main is over"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t未终止...</span><br><span class="line">t未终止...</span><br><span class="line">t未终止...</span><br><span class="line">t未终止...</span><br><span class="line">t未终止...</span><br><span class="line">t未终止...</span><br><span class="line">main thread interrupt t</span><br><span class="line">t未终止...</span><br><span class="line">t未终止...</span><br><span class="line">t未终止...</span><br><span class="line">t已终止</span><br><span class="line">main is over</span><br></pre></td></tr></table></figure>



<p>线程处于阻塞时，中断线程例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptTest4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() +<span class="string">" begin sleep for 20 seconds"</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">20</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() +<span class="string">" awaking"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() +<span class="string">" is interrupted while sleeping"</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t.setName(<span class="string">"t"</span>);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"main thread interrupt t"</span>);</span><br><span class="line">        t.interrupt();</span><br><span class="line"></span><br><span class="line">        t.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"main is over"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t begin sleep for 20 seconds</span><br><span class="line">main thread interrupt t</span><br><span class="line">t is interrupted while sleeping</span><br><span class="line">main is over</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">	at java.lang.Thread.sleep(Native Method)</span><br><span class="line">	at java.lang.Thread.sleep(Thread.java:340)</span><br><span class="line">	at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)</span><br><span class="line">	at com.fengabner.business.InterruptTest4.lambda$main$0(InterruptTest4.java:16)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<p><strong>isInterrupted()</strong>  和  <strong>interrupt()</strong> 不同之处</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        t.interrupt();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"线程是否被中断:"</span> + t.isInterrupted());<span class="comment">//A</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"线程是否被中断:"</span> + t.interrupted());<span class="comment">//B</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"线程是否被中断:"</span> + Thread.interrupted());<span class="comment">//C</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"线程是否被中断:"</span> + t.isInterrupted());<span class="comment">//D</span></span><br><span class="line"></span><br><span class="line">        t.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"main thread is over"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">线程是否被中断:true</span><br><span class="line">线程是否被中断:false</span><br><span class="line">线程是否被中断:false</span><br><span class="line">线程是否被中断:true</span><br></pre></td></tr></table></figure>

<p>从例子可以看出，A 和 D 处都会输出为 true。也说明 isInterrupted（）方法并不会清除中断状态。</p>
<p>在这里可能会有一个疑惑，为什么 B 和 C 处输出的不是一个 true 一个 false。其实这里有一个 <strong>巨大的坑</strong>，注意 <strong>interrupted()</strong> 判断的是 <strong>当前线程</strong> 是否处于中断状态， <strong>当前线程</strong>  <strong>当前线程</strong>  <strong>当前线程</strong> 。这里当前线程是main线程，而 t.interrupt(）中断的是thread线程，这里的此线程就是 t 线程。所以当前线程main从未被中断过，尽管interrupted() 方法是以 t.interrupted() 的形式被调用，但它检测的仍然是main线程而不是检测 t 线程，所以 t.interrupted() 在这里相当于main.interrupted()。</p>
<p>改一下代码测试一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        t.interrupt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//中断当前线程（mian 线程）</span></span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"线程是否被中断:"</span> + t.isInterrupted());<span class="comment">//A</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"线程是否被中断:"</span> + t.interrupted());<span class="comment">//B</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"线程是否被中断:"</span> + Thread.interrupted());<span class="comment">//C</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"线程是否被中断:"</span> + t.isInterrupted());<span class="comment">//D</span></span><br><span class="line"></span><br><span class="line">        t.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"main thread is over"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">线程是否被中断:true</span><br><span class="line">线程是否被中断:true</span><br><span class="line">线程是否被中断:false</span><br><span class="line">线程是否被中断:true</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java 并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>并发关键字 synchronized 详解</title>
    <url>/2020/05/29/synchronized/</url>
    <content><![CDATA[<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p><strong>原子性</strong></p>
<p>原子性是指一个操作是不可中断的，要全部执行完成，要不就都不执行。</p>
<a id="more"></a>

<p><strong>可见性</strong></p>
<p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p>volatile 也具备此特性</p>
<p><strong>有序性</strong></p>
<p>有序性是指程序执行的顺序按照代码的先后顺序执行。</p>
<p>volatile 也具备此特性</p>
<p><strong>可重入性</strong></p>
<p>可重入性是指同一个线程外层函数获取到锁之后，内层函数可以直接使用该锁</p>
<h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><ul>
<li><p>修饰实例方法（当前实例加锁）</p>
</li>
<li><p>修饰静态方法（类对象加锁）</p>
<blockquote>
<p>注意：如果一个线程A调用一个实例对象的非静态 synchronized方法，而线程B需要调用这个实例对象所属类的静态 synchronized方法，是<strong>允许</strong>的，不会发生互斥现象，因为访问<strong>静态 synchronized 方法占用的锁是当前类的class对象，而访问非静态 synchronized 方法占用的锁是当前实例对象锁</strong>。</p>
</blockquote>
</li>
<li><p>修饰代码块（指定一个加锁对象，对所指定的对象加锁）</p>
</li>
</ul>
<p><strong>synchronized不能被继承，不能使用Synchronized关键字修饰接口方法；构造方法也不能用Synchronized。</strong></p>
<h1 id="synchronized-底层实现原理"><a href="#synchronized-底层实现原理" class="headerlink" title="synchronized 底层实现原理"></a>synchronized 底层实现原理</h1><h2 id="sync-方法和代码块的底层实现原理"><a href="#sync-方法和代码块的底层实现原理" class="headerlink" title="sync 方法和代码块的底层实现原理"></a>sync 方法和代码块的底层实现原理</h2><p>先看简单demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do something..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"do something..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 javap -v SynchronizedDemo.class 反编译得到字节码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SynchronizedDemo</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">6</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   LSynchronizedDemo;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//修饰实例方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String do something...</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">9</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">10</span>: <span class="number">8</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  <span class="keyword">this</span>   LSynchronizedDemo;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//修饰代码块方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncBlock</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: dup</span><br><span class="line">         <span class="number">2</span>: astore_1</span><br><span class="line">         <span class="number">3</span>: monitorenter <span class="comment">//进入同步方法 将this对象的 MarkWord 置为 Monitor 指针</span></span><br><span class="line">         4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         7: ldc           #3                  // String do something...</span><br><span class="line">         9: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        <span class="number">12</span>: aload_1</span><br><span class="line">        <span class="number">13</span>: monitorexit <span class="comment">//退出同步方法 将this对象 MarkWord 重置，唤醒 EntryList</span></span><br><span class="line">        <span class="number">14</span>: goto          <span class="number">22</span></span><br><span class="line">        <span class="number">17</span>: astore_2</span><br><span class="line">        <span class="number">18</span>: aload_1</span><br><span class="line">        <span class="number">19</span>: monitorexit <span class="comment">//退出同步方法 将this对象 MarkWord 重置，唤醒 EntryList</span></span><br><span class="line">        <span class="number">20</span>: aload_2</span><br><span class="line">        <span class="number">21</span>: athrow</span><br><span class="line">        <span class="number">22</span>: <span class="keyword">return</span></span><br><span class="line">      Exception table:<span class="comment">//异常检测，如果发现14-17中有异常出现，就从17行处继续执行，这也就是为什么会有两个monitorexit的原因</span></span><br><span class="line">         from    to  target type</span><br><span class="line">             <span class="number">4</span>    <span class="number">14</span>    <span class="number">17</span>   any</span><br><span class="line">            <span class="number">17</span>    <span class="number">20</span>    <span class="number">17</span>   any</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">13</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">14</span>: <span class="number">4</span></span><br><span class="line">        line <span class="number">15</span>: <span class="number">12</span></span><br><span class="line">        line <span class="number">16</span>: <span class="number">22</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">23</span>     <span class="number">0</span>  <span class="keyword">this</span>   LSynchronizedDemo;</span><br><span class="line">      StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">        frame_type = <span class="number">255</span> <span class="comment">/* full_frame */</span></span><br><span class="line">          offset_delta = <span class="number">17</span></span><br><span class="line">          locals = [ class SynchronizedDemo, class java/lang/Object ]</span><br><span class="line">          stack = [ class java/lang/Throwable ]</span><br><span class="line">        frame_type = <span class="number">250</span> <span class="comment">/* chop */</span></span><br><span class="line">          offset_delta = <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从字节码可以看出</p>
<p>1、同步方法是利用 <strong>ACC_SYNCHRONIZED</strong> 这个修饰符来实现的</p>
<blockquote>
<p>同步方法是通过隐式的方式来实现的。用ACC_SYNCHRONIZED来标识。</p>
<p>意思就是：当方法调用时，调用指令将会去检查这个方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor（注意这个完成包括非正常的完成比如异常）。在方法执行期间，其他的线程都将无法再获得同一个monitor对象。</p>
</blockquote>
<p>2、同步代码块是利用 <strong>monitorenter</strong> 和 <strong>monitorexit</strong> 这2个指令来实现的</p>
<blockquote>
<p>monitorenter指令指向同步代码块的开始位置，monitorexit指令指向同步代码块的结束位置。</p>
<p>monitorenter：</p>
<p>每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：</p>
<p>1、如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。</p>
<p>2、如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.</p>
<p>3.如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。</p>
<p>monitorexit：</p>
<p>执行monitorexit的线程必须是objectref所对应的monitor的所有者。</p>
<p>指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。 </p>
</blockquote>
<p>3、同步代码块的字节码可发现 有两个 monitorexit，为何会有两个？</p>
<blockquote>
<p>主要是防止在同步代码块中线程因异常退出，而锁没有得到释放，这必然会造成死锁（等待的线程永远获取不到锁）。因此最后一个monitorexit是保证在异常情况下，锁也可以得到释放，避免死锁。</p>
</blockquote>
<h2 id="java对象头"><a href="#java对象头" class="headerlink" title="java对象头"></a>java对象头</h2><p>synchronized使用的锁对象是存储在Java对象头里的。如果对象是数组类型，则虚拟机用3个Word（字宽）存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，一字宽等于四字节，即32bit。</p>
<table>
<thead>
<tr>
<th>长度</th>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>32/64bit</td>
<td>Mark Word</td>
<td>存储对象的hashCode或锁信息等。</td>
</tr>
<tr>
<td>32/64bit</td>
<td>Class Metadata Address</td>
<td>存储到对象类型数据的指针</td>
</tr>
<tr>
<td>32/64bit</td>
<td>Array length</td>
<td>数组的长度（如果当前对象是数组）</td>
</tr>
</tbody></table>
<p>Java对象头里的Mark Word里默认存储对象的HashCode，分代年龄和锁标记位。32位JVM的Mark Word的默认存储结构如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>25 bit</th>
<th>4bit</th>
<th>1bit是否是偏向锁</th>
<th>2bit锁标志位</th>
</tr>
</thead>
<tbody><tr>
<td>无锁状态</td>
<td>对象的hashCode</td>
<td>对象分代年龄</td>
<td>0</td>
<td>01</td>
</tr>
</tbody></table>
<p>在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。Mark Word可能变化为存储以下4种数据： </p>
<table>
<thead>
<tr>
<th>锁状态</th>
<th>25 bit</th>
<th>4bit</th>
<th>1bit</th>
<th>2bit</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>23bit</td>
<td>2bit</td>
<td>是否是偏向锁</td>
<td>锁标志位</td>
<td></td>
<td></td>
</tr>
<tr>
<td>轻量级锁</td>
<td>指向栈中锁记录的指针</td>
<td>00</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>重量级锁</td>
<td>指向互斥量（重量级锁）的指针</td>
<td>10</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>GC标记</td>
<td>空</td>
<td>11</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>偏向锁</td>
<td>线程ID</td>
<td>Epoch</td>
<td>对象分代年龄</td>
<td>1</td>
<td>01</td>
</tr>
</tbody></table>
<p>上表里面的GC标记，为11的话，推断应该是准备GC的意思。</p>
<p>在64位虚拟机下，Mark Word是64bit大小的，其存储结构如下： </p>
<table>
<thead>
<tr>
<th>锁状态</th>
<th>25bit</th>
<th>31bit</th>
<th>1bit</th>
<th>4bit</th>
<th>1bit</th>
<th>2bit</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td>cms_free</td>
<td>分代年龄</td>
<td>偏向锁</td>
<td>锁标志位</td>
<td></td>
</tr>
<tr>
<td>无锁</td>
<td>unused</td>
<td>hashCode</td>
<td></td>
<td></td>
<td>0</td>
<td>01</td>
</tr>
<tr>
<td>偏向锁</td>
<td>ThreadID(54bit) Epoch(2bit)</td>
<td></td>
<td></td>
<td>1</td>
<td>01</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>以上java对象头的表格概括引用：</p>
<p><a href="https://www.cnblogs.com/charlesblc/p/5994162.html" target="_blank" rel="noopener">https://www.cnblogs.com/charlesblc/p/5994162.html</a></p>
</blockquote>
<p>上面看到的<strong>重量级锁也就是通常说synchronized的对象锁</strong>，锁标识位为<strong>10</strong>，其中指针指向的是<strong>monitor对象的起始地址</strong>。每个对象都存在着一个 monitor 与之关联，对象与其 monitor 之间的关系有存在多种实现方式，如<strong>monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成</strong>，但当一个 monitor 被某个线程持有后，它便处于锁定状态。</p>
<p>在Java虚拟机(HotSpot)中，<strong>monitor</strong>是由ObjectMonitor实现的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = NULL;</span><br><span class="line">    _count        = 0; //记录个数 记录该线程获取锁的次数</span><br><span class="line">    _waiters      = 0, //等待线程数</span><br><span class="line">    _recursions   = 0; //锁的冲入次数</span><br><span class="line">    _object       = NULL;</span><br><span class="line">    _owner        = NULL;  //_owner指向持有ObjectMonitor对象的线程</span><br><span class="line">    _WaitSet      = NULL; //处于wait状态的线程，会被加入到_WaitSet</span><br><span class="line">    _WaitSetLock  = 0 ;</span><br><span class="line">    _Responsible  = NULL ;</span><br><span class="line">    _succ         = NULL ;</span><br><span class="line">    _cxq          = NULL ;</span><br><span class="line">    FreeNext      = NULL ;</span><br><span class="line">    _EntryList    = NULL ; //处于等待锁block状态的线程，会被加入到该列表</span><br><span class="line">    _SpinFreq     = 0 ;</span><br><span class="line">    _SpinClock    = 0 ;</span><br><span class="line">    OwnerIsThread = 0 ; //监视器前一个拥有者线程的ID</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>当多个线程同时访问一段同步代码时，首先会进入 _EntryList 集合，当线程获取到对象的monitor 后进入 _Owner 区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1，若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSet集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)</p>
<blockquote>
<p>此解释引用：<a href="https://blog.csdn.net/javazejian/article/details/72828483" target="_blank" rel="noopener">https://blog.csdn.net/javazejian/article/details/72828483</a></p>
</blockquote>
<h2 id="为什么Java的任意对象都可以作为锁？"><a href="#为什么Java的任意对象都可以作为锁？" class="headerlink" title="为什么Java的任意对象都可以作为锁？"></a>为什么Java的任意对象都可以作为锁？</h2><p>在Java对象头中，存在一个monitor对象，每个对象自创建之后在对象头中就含有monitor对象，monitor是线程私有的，不同的对象monitor自然也是不同的，因此对象作为锁的本质是对象头中的monitor对象作为了锁。这便是为什么Java的任意对象都可以作为锁的原因。</p>
<h2 id="Monitor的机制"><a href="#Monitor的机制" class="headerlink" title="Monitor的机制"></a>Monitor的机制</h2><p><img src="/.com//image-20200528153829565.png" alt="image-20200528153829565"></p>
<p>当一个线程需要获取 Object 的锁时，会被放入 <strong>EntrySet</strong> 中进行等待，如果该线程获取到了锁，成为当前锁的 <strong>owner</strong>。如果根据程序逻辑，一个已经获得了锁的线程缺少某些外部条件，而无法继续进行下去（例如生产者发现队列已满或者消费者发现队列为空），那么该线程可以通过调用 wait 方法将锁释放，进入 <strong>wait set</strong> 中阻塞进行等待，其它线程在这个时候有机会获得锁，去干其它的事情，从而使得之前不成立的外部条件成立，这样先前被阻塞的线程就可以重新进入 <strong>EntrySet</strong> 去竞争锁。这个外部条件在 <strong>monitor</strong> 机制中称为条件变量。</p>
<p><strong>普通对象没有 Monitor</strong></p>
<h1 id="Jvm优化"><a href="#Jvm优化" class="headerlink" title="Jvm优化"></a>Jvm优化</h1><p>Java 的锁分为两种：</p>
<p>1、一种是内部锁，它用 <strong>Synchronized</strong> 关键字来修饰，由 JVM 负责管理，并且不会出现锁泄漏的情况。</p>
<p>2、另外一种是显示锁。</p>
<p>​    内部锁的优化方式由 Java 内部机制完成，虽然不需要程序员直接参与，但了解它对会更容易让我们理解多线程。</p>
<p>​    JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。 </p>
<p>　<strong>锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。</strong>他们会随着竞争的激烈而逐渐升级。但是锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>
<h2 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h2><p><strong>锁有四种状态，并且会因实际情况进行膨胀升级，其膨胀方向是：无锁—&gt;偏向锁—&gt;轻量级锁—&gt;重量级锁，并且膨胀方向不可逆。</strong></p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>在大多数情况下，锁不存在多线程竞争，总是由同一线程多次获得，那么此时就是偏向锁。</p>
<p>1、首先检测是否为可偏向状态（锁标识是否设置成1，锁标志位是否为01）.<br>2、如果处于可偏向状态，测试Mark Word中的线程ID是否指向自己，如果是，不需要再次获取锁，直接执行同步代码。<br>3、如果线程Id，不是自己的线程Id，通过CAS获取锁，获取成功表明当前偏向锁不存在竞争，获取失败，则说明当前偏向锁存在锁竞争，偏向锁膨胀为 <strong>轻量级锁</strong>。</p>
<p><img src="/.com//image-20200529173233623.png" alt="image-20200529173233623"></p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁是由偏向锁升级而来，当存在第二个线程申请同一个锁对象时，偏向锁就会立即升级为轻量级锁。注意这里的第二个线程只是申请锁，不存在两个线程同时竞争锁，可以是一前一后地交替执行同步块。</p>
<p><strong>偏向锁考虑的是不存在多个线程竞争同一把锁，而轻量级锁考虑的是，多个线程不会在同一时刻来竞争同一把锁。</strong></p>
<p>加锁：</p>
<p>1、首先会先去检查Mark Word中锁标记是否为01。如果是JVM虚拟机就会在该线程的栈帧中创建一个Lock Record（锁记录）内存空间，用于存储Mark Word的拷贝。</p>
<p>2、将Mark Word拷贝到锁记录中。官方称为Displaced Mark Word。</p>
<p>3、尝试将锁对象中的标记字段替换成一个指针，该指针指向该线程的锁记录空间，并将锁记录中owner指针指向当前线程的对象头。如果更新成功执行步骤4，否则执行步骤5.</p>
<p>4、更新成功表明该线程拥有了该对象锁，并且锁记录变为00</p>
<p>5、更新失败，先检查Mark Word中的指针是否指向当前线程的栈帧，如果是，表明线程已经获取了该对象锁。否则表明，存在多个线程竞争，这时膨胀为重量级锁，锁记录变为10，后面等待的线程进入到阻塞状态，并且当前线程自旋尝试获取锁。</p>
<p>解锁：</p>
<p>1、通过CAS操作尝试将线程栈帧中的锁记录替换掉堆中Mark Word</p>
<p>2、成功，锁释放成功</p>
<p>3、失败，表明此时锁已经升级为重量级锁，在释放锁的同时需要唤醒被挂起的线程。</p>
<p><img src="/.com//image-20200529225908860.png" alt="image-20200529225908860"></p>
<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p><strong>重量级锁描述同一时刻有多个线程竞争同一把锁。</strong></p>
<p>重量级锁是由轻量级锁升级而来，当同一时间有多个线程竞争锁时，锁就会被升级成重量级锁，此时其申请锁带来的开销也就变大。</p>
<p>重量级锁一般使用场景会在追求吞吐量，同步块或者同步方法执行时间较长的场景。</p>
<h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p>在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，对运行上下文进行扫描，去除不可能存在竞争的锁  举例：在一个方法中存在被StringBuffer修饰的成员变量，由于该变量只会在该方法中使用，不能被其他线程锁共享，所以JVM会自动消除其内部的锁。</p>
<h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><p>锁粗化是虚拟机对另一种极端情况的优化处理，通过扩大锁的范围，避免反复加锁和释放锁。也就是将多次连接在一起的加锁、解锁操作合并为一次，将多个连续的锁扩展成一个范围更大的锁</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBufferTest</span> </span>&#123;</span><br><span class="line">    StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">append</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stringBuffer.append(<span class="string">"a"</span>);</span><br><span class="line">        stringBuffer.append(<span class="string">"b"</span>);</span><br><span class="line">        stringBuffer.append(<span class="string">"c"</span>);</span><br><span class="line">        stringBuffer.append(<span class="string">"d"</span>);</span><br><span class="line">        stringBuffer.append(<span class="string">"e"</span>);</span><br><span class="line">        stringBuffer.append(<span class="string">"f"</span>);</span><br><span class="line">        stringBuffer.append(<span class="string">"g"</span>);</span><br><span class="line">        stringBuffer.append(<span class="string">"h"</span>);</span><br><span class="line">        stringBuffer.append(<span class="string">"i"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>每次调用stringBuffer.append方法都需要加锁和解锁，如果虚拟机检测到有一系列连串的对同一个对象加锁和解锁操作，就会将其合并成一次范围更大的加锁和解锁操作，即在第一次append方法时进行加锁，最后一次append方法结束后进行解锁。</p>
<h2 id="自旋锁与自适应自旋锁"><a href="#自旋锁与自适应自旋锁" class="headerlink" title="自旋锁与自适应自旋锁"></a>自旋锁与自适应自旋锁</h2><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。</p>
<p><strong>所谓自旋，不是获取不到锁就会阻塞，而是在原地等待一会儿，再次尝试（次数或时长有限），他是以牺牲CPU为代价来换取内核状态切换带来的开销。</strong></p>
<p>缺点：若线程占用锁时间过长，导致CPU资源白白浪费。</p>
<p>解决方式：当尝试次数达到每个值得时候，线程挂起。</p>
<h3 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h3><p>这种相当于是对 <strong>自旋锁</strong> 优化方式的进一步优化，它的自旋的次数不再固定，其自旋的次数由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定，这就解决了自旋锁带来的缺点。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><blockquote>
<p>图片引用：<a href="https://jacobchang.cn/media/v2-9db4211af1be81785f6cc51a58ae6054_r.jpg" target="_blank" rel="noopener">https://jacobchang.cn/media/v2-9db4211af1be81785f6cc51a58ae6054_r.jpg</a></p>
</blockquote>
<p><img src="/.com//v2-9db4211af1be81785f6cc51a58ae6054_r-1590764485134.jpg" alt="v2-9db4211af1be81785f6cc51a58ae6054_r"></p>
]]></content>
      <categories>
        <category>java 并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>并发关键字 volatile 详解</title>
    <url>/2020/06/07/volatile/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>​    增加了实例变量在多个线程之间的可见性，但不具备同步性也就不具备原子性。</p>
<p>​    volatile关键字常被称为轻量级锁 ，其作用与锁的作用有相同的地方：<strong>保证可见性和有序性</strong>。并不保证操作的原子性。</p>
<p>​    被volatile修饰的变量能够保证每个线程能够获取该变量的最新值，从而避免出现数据脏读的现象。</p>
<a id="more"></a>

<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><h2 id="防止内存重排"><a href="#防止内存重排" class="headerlink" title="防止内存重排"></a>防止内存重排</h2><h3 id="指令重排概念"><a href="#指令重排概念" class="headerlink" title="指令重排概念"></a>指令重排概念</h3><p>指令重排序是JVM为了优化指令，提高程序运行效率，在不影响单线程程序执行结果的前提下，尽可能地提高并行度。编译器、处理器也遵循这样一个目标。注意是单线程。多线程的情况下指令重排序就会给程序员带来问题。</p>
<p>不同的指令间可能存在数据依赖。比如下面计算圆的面积的语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double r &#x3D; 2.3d;&#x2F;&#x2F;a</span><br><span class="line"></span><br><span class="line">double pi &#x3D;3.1415926; &#x2F;&#x2F;b</span><br><span class="line"></span><br><span class="line">double area &#x3D; pi* r * r; &#x2F;&#x2F;c</span><br></pre></td></tr></table></figure>

<p>area的计算依赖于r与pi两个变量的赋值指令。而r与pi无依赖关系。</p>
<p>as-if-serial语义是指：不管如何重排序（编译器与处理器为了提高并行度），（单线程）程序的结果不能被改变。这是编译器、Runtime、处理器必须遵守的语义。</p>
<p>虽然，</p>
<p>a - happensbefore -&gt; b,</p>
<p>b - happens before -&gt; c，</p>
<p>但是计算顺序 <strong>a-&gt; b-&gt; c</strong> 与 *<em>b-&gt; a-&gt; c *</em> 对于r、pi、area变量的结果并无区别。编译器、Runtime在优化时可以根据情况重排序 a 与 b，而丝毫不影响程序的结果。</p>
<p>指令重排序包括编译器重排序和运行时重排序。</p>
<h3 id="指令重排带来的问题"><a href="#指令重排带来的问题" class="headerlink" title="指令重排带来的问题"></a>指令重排带来的问题</h3><p>首先来看一个例子：单例模式-懒汉式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton4 INSTANCE;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton4</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;<span class="comment">//此处会存在竞态条件，会导致 INSTANCE 会被多次赋值</span></span><br><span class="line">			</span><br><span class="line">			INSTANCE = <span class="keyword">new</span> Singleton4();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> INSTANCE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了防止这种情况，因此有了DCL（Double Check Lock，双重检查锁）机制，使得大部分请求都不会进入阻塞代码块。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton6</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton6 INSTANCE;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton6</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton6 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;<span class="comment">//当instance不为null时，仍可能指向一个“被部分初始化的对象”</span></span><br><span class="line">			<span class="keyword">synchronized</span> (Singleton6<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">				<span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">					INSTANCE = <span class="keyword">new</span> Singleton6();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> INSTANCE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会再存在一个问题。当instance不为null时，仍可能指向一个“被部分初始化的对象”。因为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">INSTANCE = <span class="keyword">new</span> Singleton6();</span><br></pre></td></tr></table></figure>

<p>此处并不是一个原子操作。有可能会进行指令重排。</p>
<p>实例化一个对象可以分为三个步骤</p>
<ul>
<li>分配内存空间。</li>
<li>初始化对象。</li>
<li>将内存空间的地址赋值给对应的引用。</li>
</ul>
<p>但是由于操作系统可以 <strong>对指令进行重排序</strong>，所以上面的过程也可能会变成如下过程：</p>
<ul>
<li>分配内存空间。</li>
<li>将内存空间的地址赋值给对应的引用。</li>
<li>初始化对象</li>
</ul>
<p>如果是这个流程，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。为了解决这个为题，只需要加上volatile</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton6 INSTANCE;<span class="comment">// volatile 防止内存重排</span></span><br></pre></td></tr></table></figure>

<h3 id="volatile-如何防止指令重排"><a href="#volatile-如何防止指令重排" class="headerlink" title="volatile 如何防止指令重排"></a>volatile 如何防止指令重排</h3><p>volatile关键字通过 <strong>内存屏障</strong> 来防止指令被重排序。</p>
<h4 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h4><p>JMM(java 内存模型) 在不改变程序执行结果的前提下，尽可能的支持处理器的重排序。通过禁止特定特定类型的编译器重排序和处理器重排序，为开发者提供一致的内存可见性保证，如 volatile、final。</p>
<p>Java编译器在生成指令的时候会在适当位置插入内存屏障来进制特定类型的处理器排序。</p>
<p>内存屏障说的通俗一点就是一个栏杆，在两个指令之间插入栏杆，后面的指令就不能越过栏杆先执行。</p>
<blockquote>
<p>A memory barrier, also known as a membar, memory fence or fence instruction, is a type of barrier instruction that causes a CPU or compiler to enforce an ordering constraint on memory operations issued before and after the barrier instruction. This typically means that operations issued prior to the barrier are guaranteed to be performed before operations issued after the barrier.</p>
</blockquote>
<h4 id="内存屏障分类"><a href="#内存屏障分类" class="headerlink" title="内存屏障分类"></a>内存屏障分类</h4><p><strong>LoadLoad屏障</strong>：</p>
<p>抽象场景：Load1; LoadLoad; Load2</p>
<p>Load1 和 Load2 代表两条读取指令。在Load2要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</p>
<p><strong>StoreStore屏障：</strong></p>
<p>抽象场景：Store1; StoreStore; Store2</p>
<p>Store1 和 Store2代表两条写入指令。在Store2写入执行前，保证Store1的写入操作对其它处理器可见</p>
<p><strong>LoadStore屏障：</strong></p>
<p>抽象场景：Load1; LoadStore; Store2</p>
<p>在Store2被写入前，保证Load1要读取的数据被读取完毕。</p>
<p><strong>StoreLoad屏障：</strong></p>
<p>抽象场景：Store1; StoreLoad; Load2</p>
<p>在Load2读取操作执行前，保证Store1的写入对所有处理器可见。StoreLoad屏障的开销是四种屏障中最大的。</p>
<h4 id="volatile-处理"><a href="#volatile-处理" class="headerlink" title="volatile 处理"></a>volatile 处理</h4><ul>
<li>在每个volatile写操作的前面插入一个StoreStore屏障。</li>
<li>在每个volatile写操作的后面插入一个StoreLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadStore屏障。</li>
</ul>
<p>volatile 写是在前面和后面分别插入内存屏障，而 volatile 读操作是在后面插入两个内存屏障。</p>
<table>
<thead>
<tr>
<th>内存屏障</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>StoreStore 屏障</td>
<td>禁止上面的普通写和下面的 volatile 写重排序。</td>
</tr>
<tr>
<td>StoreLoad 屏障</td>
<td>防止上面的 volatile 写与下面可能有的 volatile 读/写重排序。</td>
</tr>
<tr>
<td>LoadLoad 屏障</td>
<td>禁止下面所有的普通读操作和上面的 volatile 读重排序。</td>
</tr>
<tr>
<td>LoadStore 屏障</td>
<td>禁止下面所有的普通写操作和上面的 volatile 读重排序。</td>
</tr>
</tbody></table>
<p><img src="/.com//volatile-1.png" alt="volatile-1"></p>
<p><img src="/.com//volatile-2.png" alt="volatile-2"></p>
<h2 id="保证内存可见性"><a href="#保证内存可见性" class="headerlink" title="保证内存可见性"></a>保证内存可见性</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p>Java 内存模型规定，对于多个线程共享的变量，存储在主内存当中，每个线程都有自己独立的工作内存，并且线程只能访问自己的工作内存，不可以访问其它线程的工作内存。工作内存中保存了主内存中共享变量的副本，线程要操作这些共享变量，只能通过操作工作内存中的副本来实现，操作完毕之后再同步回到主内存当中，其 JVM 模型大致如下图。</p>
<p><img src="/.com//neicun.jpeg" alt="neicun"></p>
<h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>Java通过8种原子操作完成<strong>工作内存</strong>和<strong>主内存</strong>的交互：</p>
<ul>
<li><p>lock：作用于主内存，把变量标识为线程独占状态。</p>
</li>
<li><p>unlock：作用于主内存，解除独占状态。</p>
</li>
<li><p>read：作用主内存，把一个变量的值从主内存传输到线程的工作内存。</p>
</li>
<li><p>load：作用于工作内存，把read操作传过来的变量值放入工作内存的变量副本中。</p>
</li>
<li><p>use：作用工作内存，把工作内存当中的一个变量值传给执行引擎。</p>
</li>
<li><p>assign：作用工作内存，把一个从执行引擎接收到的值赋值给工作内存的变量。</p>
</li>
<li><p>store：作用于工作内存的变量，把工作内存的一个变量的值传送到主内存中。</p>
</li>
<li><p>write：作用于主内存的变量，把store操作传来的变量的值放入主内存的变量中。</p>
</li>
</ul>
<p>其中lock和unlock定义了一个线程访问一次共享内存的界限。</p>
<h3 id="volatile-处理-1"><a href="#volatile-处理-1" class="headerlink" title="volatile 处理"></a>volatile 处理</h3><ul>
<li>read、load、use动作必须连续出现。</li>
<li>assign、store、write动作必须连续出现。</li>
</ul>
<p>所以，使用volatile变量能够保证:</p>
<ul>
<li>每次读取前必须先从主内存刷新最新的值。</li>
<li>每次写入后必须立即同步回主内存当中。</li>
</ul>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><ul>
<li>只有一个线程写，多个线程读</li>
<li>对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。</li>
<li>该变量没有包含在具有其他变量的不变式中。</li>
</ul>
]]></content>
      <categories>
        <category>java 并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之单例模式</title>
    <url>/2020/05/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p>类加载到内存后，就实例化一个单例，JVM会保证线程安全(JVM 保证一个class 只会落到内存一次，只加载一次）</p>
<p>缺点：不管用到与否，类装载时就完成实例化</p>
<a id="more"></a>

<p>第一种：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 类加载到内存后，就实例化一个单例，JVM会保证线程安全(JVM 保证一个class 只会落到内存一次，只加载一次）</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 缺点：不管用到与否，类装载时就完成实例化</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span>  <span class="keyword">final</span> <span class="keyword">static</span> Singleton1 INSTANCE = <span class="keyword">new</span> Singleton1();<span class="comment">//静态变量到内存就会初始化</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> INSTANCE;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"do something"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">		Singleton1 singleton1  = Singleton1.getInstance();</span><br><span class="line">		Singleton1 singleton12 = Singleton1.getInstance();</span><br><span class="line">		System.out.println(singleton1 == singleton12);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton3 INSTANCE;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		INSTANCE = <span class="keyword">new</span> Singleton3();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> INSTANCE;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Singleton3 singleton1  = Singleton3.getInstance();</span><br><span class="line">		Singleton3 singleton12 = Singleton3.getInstance();</span><br><span class="line">		System.out.println(singleton1 == singleton12);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="静态内部类方式"><a href="#静态内部类方式" class="headerlink" title="静态内部类方式"></a>静态内部类方式</h2><p>加载外部类时不会加载内部类，这样可以实现懒加载 ，JVM 保证单例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类方式 （完美方式）</span></span><br><span class="line"><span class="comment"> * JVM 保证单例</span></span><br><span class="line"><span class="comment"> * 加载外部类时不会加载内部类，这样可以实现懒加载 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Hoder</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton2 INSTANCE = <span class="keyword">new</span> Singleton2();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Hoder.INSTANCE;<span class="comment">//这时候会加载静态内部类</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSometing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(() -&gt;  &#123;</span><br><span class="line">				System.out.println(Singleton2.getInstance().hashCode());</span><br><span class="line">			&#125; ).start();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>达到了按需初始化的目的，但是线程不安全</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式</span></span><br><span class="line"><span class="comment"> * 达到了按需初始化的目的，但是线程不安全</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton4 INSTANCE;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton4</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">1</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			INSTANCE = <span class="keyword">new</span> Singleton4();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> INSTANCE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(() -&gt;  &#123;</span><br><span class="line">				System.out.println(Singleton4.getInstance().hashCode());</span><br><span class="line">			&#125; ).start();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用 synchronized 解决线程安全问题，但是效率会降低</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式</span></span><br><span class="line"><span class="comment"> * 达到了按需初始化的目的，但是线程不安全</span></span><br><span class="line"><span class="comment"> * 可以使用 synchronized 解决，但是效率会降低</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton5</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton5 INSTANCE;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton5</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton5 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">1</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			INSTANCE = <span class="keyword">new</span> Singleton5();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> INSTANCE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(() -&gt;  &#123;</span><br><span class="line">				System.out.println(Singleton5.getInstance().hashCode());</span><br><span class="line">			&#125; ).start();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双重检查"><a href="#双重检查" class="headerlink" title="双重检查"></a>双重检查</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双重检查</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton6</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton6 INSTANCE;<span class="comment">// volatile 防止内存重排</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton6</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton6 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">synchronized</span> (Singleton6<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">				<span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">					</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">1</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					INSTANCE = <span class="keyword">new</span> Singleton6();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> INSTANCE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(() -&gt;  &#123;</span><br><span class="line">				System.out.println(Singleton6.getInstance().hashCode());</span><br><span class="line">			&#125; ).start();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="枚举单例"><a href="#枚举单例" class="headerlink" title="枚举单例"></a>枚举单例</h2><p>可以解决线程安全，并且可以防止反序列化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 枚举单例  可以解决线程安全，并且可以防止反序列化</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Java 的反射可以通过一个class 文件把整个class 落在内存，然后new一个实例出来的。</span></span><br><span class="line"><span class="comment"> * 枚举类没有构造方法，拿到class文件也没办法反序列化 反编译之后枚举是一个abstract class</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton7 &#123;</span><br><span class="line"></span><br><span class="line">	INSTANCE;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(() -&gt;  &#123;</span><br><span class="line">				System.out.println(Singleton7.INSTANCE.hashCode());</span><br><span class="line">			&#125; ).start();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>借鉴了马士兵老师讲的设计模式</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之策略模式</title>
    <url>/2020/05/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li><p>算法自由切换</p>
<blockquote>
<p>只要实现抽象策略，就成为了策略家族的一个成员，通过封装角色对其进行封装，保证对外提供“可自由切换”的策略</p>
</blockquote>
</li>
</ul>
<a id="more"></a>

<ul>
<li><p>避免使用多重条件判断</p>
<blockquote>
<p>多重条件不易维护，而且出错概率会提高。</p>
</blockquote>
</li>
<li><p>扩展性好</p>
<blockquote>
<p>只要实现接口就行，其他都不用修改，类似于一个可反复拆卸的插件</p>
</blockquote>
</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li><p>策略类数量增多</p>
<blockquote>
<p>每一个策略都是一个类，复用的可能性啃小，类数量增多</p>
</blockquote>
</li>
<li><p>策略类需要对外暴露</p>
</li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>说明：排序中可以使用不同的排序，比如冒泡排序、快速排序、堆排序等</p>
<p>定义一个接口 AlgorithmStrategy 定义排序算法类型，而这些类型都有各自计算的过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 算法类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AlgorithmStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Algorithm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AlgorithmStrategy algorithmStrategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Algorithm</span><span class="params">(AlgorithmStrategy algorithmStrategy)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.algorithmStrategy = algorithmStrategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.algorithmStrategy.sort();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSortAlgorithmStrategy</span> <span class="keyword">implements</span> <span class="title">AlgorithmStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我在使用冒泡排序算法......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSortAlgorithmStrategy</span> <span class="keyword">implements</span> <span class="title">AlgorithmStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我在使用堆排序算法......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSortAlgorithmStrategy</span> <span class="keyword">implements</span> <span class="title">AlgorithmStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我在使用快速排序算法......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AlgorithmStrategy algorithmStrategy = <span class="keyword">new</span> BubbleSortAlgorithmStrategy();</span><br><span class="line">        Algorithm algorithm = <span class="keyword">new</span> Algorithm(algorithmStrategy);</span><br><span class="line">        algorithm.calculateSort();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我在使用冒泡排序算法......</span><br></pre></td></tr></table></figure>

<p>这个策略很简单，但是把各种算法类型都暴露出去了，往往策略模式不会单独使用，会和其他设计模式一起使用，比如和简单工厂一起使用，就能解决这个暴露的问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 算法选择</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlgorithmFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AlgorithmStrategy <span class="title">getAlgorithmStrategy</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"bubble"</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BubbleSortAlgorithmStrategy();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"heap"</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HeapSortAlgorithmStrategy();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"quick"</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> QuickSortAlgorithmStrategy();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BubbleSortAlgorithmStrategy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AlgorithmStrategy algorithmStrategy = <span class="keyword">new</span> BubbleSortAlgorithmStrategy();</span><br><span class="line">        Algorithm algorithm = <span class="keyword">new</span> Algorithm(algorithmStrategy);</span><br><span class="line">        algorithm.calculateSort();</span><br><span class="line"></span><br><span class="line">        AlgorithmStrategy algorithmStrategy1=AlgorithmFactory.getAlgorithmStrategy(<span class="string">"heap"</span>);</span><br><span class="line">        Algorithm algorithm1 = <span class="keyword">new</span> Algorithm(algorithmStrategy1);</span><br><span class="line">        algorithm1.calculateSort();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我在使用冒泡排序算法......</span><br><span class="line">我在使用堆排序算法......</span><br></pre></td></tr></table></figure>



<blockquote>
<p>借鉴《深入理解java虚拟机》</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>tomcat总体架构</title>
    <url>/2021/04/12/tomcat%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="总体架构设计"><a href="#总体架构设计" class="headerlink" title="总体架构设计"></a>总体架构设计</h1><p>Tomcat既按照 Servlet 规范的要求去实现了 Servlet 容器，同时它也具有HTTP服务器的功能。</p>
<p>Tomcat 具备两个身份 「<code>Http</code> 服务器 + <code>Servlet</code> 容器」</p>
<a id="more"></a>

<p><img src="http://tencent.fengabner.com/ap-guangzhoutomcat02.png" alt="tomcat02"></p>
<h2 id="Tomcat-总体结构图"><a href="#Tomcat-总体结构图" class="headerlink" title="Tomcat 总体结构图"></a>Tomcat 总体结构图</h2><p><img src="http://tencent.fengabner.com/ap-guangzhoutomcat01.png" alt="image-20210406181308096"></p>
<ul>
<li><font color="red">Server</font> 是最顶级的组件，代表Tomcat的运行实例，在一个jvm中止会包含一个Server。</li>
<li><font color="red">Service</font> 一个Server可以包含至少一个Service，用于具体提供服务。</li>
<li><font color="red">Connector</font> 一个Service 可以包含多个Connector。用于接受请求并将请求封装成Request和Response来具体处理。（作用是监听客户端请求，并将请求封装提交container处理，然后将处理结果返回客户端）</li>
<li><font color="red">Container</font> 容器。负责处理用户的Servlet请求。</li>
</ul>
<p><img src="http://tencent.fengabner.com/ap-guangzhoutomcat03.png" alt="tomcat03"></p>
<ul>
<li><font color="red">Engine</font> 表示一个虚拟主机的引擎。引擎管理多个站点(Host)，一个Service一个Engine。但是⼀个引擎可包含多个Host。</li>
<li><font color="red">Host</font>  代表一个站点，也可以叫虚拟主机，通过配置Host就可以添加站点。一个Engine可以有多个虚拟主机，每个主机都有对应的域名，在 Tomcat 中，一个 webapps 就代表一个虚拟主机， webapps 也可以配置多个。</li>
<li><font color="red">Context</font> 表示⼀个Web应⽤程序， ⼀个Web应⽤可包含多个Wrapper。</li>
<li><font color="red">Wrapper </font>可以有多个Wrapper，每一Wrapper封装着一个Servlet。它负责管理一个 Servlet，包括的 Servlet 的装载、初始化、执行以及资源回收。Wrapper 作为容器中的最底层，不能包含⼦容器。</li>
</ul>
<h2 id="Catalina"><a href="#Catalina" class="headerlink" title="Catalina"></a>Catalina</h2><p>Tomcat是⼀个由⼀系列可配置（conf/server.xml）的组件构成的Web容器，⽽Catalina是Tomcat的servlet容器。</p>
<p>从另⼀个⻆度来说，<strong>Tomcat</strong> <strong>本质上就是⼀款</strong> <strong>Servlet</strong> <strong>容器</strong>， 因为 Catalina 才是 Tomcat 的核⼼ ， 其他模块都是为Catalina 提供⽀撑的。</p>
<p>如 ： 通过 Coyote 模块提供链接通信，Jasper 模块提供 JSP 引擎，Naming 提供JNDI 服务，Juli 提供⽇志服务。</p>
<p>分层示意图</p>
<p><img src="http://tencent.fengabner.com/ap-guangzhoutomcat04.png" alt="tomcat04"></p>
<h2 id="Coyote"><a href="#Coyote" class="headerlink" title="Coyote"></a>Coyote</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Coyote 是Tomcat链接器框架的名称。是Tomcat对外的接口，客户端通过Coyote与服务器建立链接、发送请求并接收响应。</p>
<p><img src="http://tencent.fengabner.com/ap-guangzhoutomcat05.png" alt="tomcat05"></p>
<ul>
<li><p>Coyote 封装了底层的⽹络通信（Socket 请求及响应处理）</p>
</li>
<li><p>Coyote 使Catalina 容器（容器组件）与具体的请求协议及IO操作⽅式完全解耦</p>
</li>
<li><p>Coyote 将Socket 输⼊转换封装为 Request 对象，进⼀步封装后交由Catalina 容器进⾏处理，处理请求完成后, Catalina 通过Coyote 提供的Response 对象将结果写⼊输出流</p>
</li>
<li><p>Coyote 负责的<strong>是具体协议（应⽤层）和**</strong>IO<strong>**（传输层）相关内容</strong></p>
</li>
</ul>
<h3 id="IO-协议"><a href="#IO-协议" class="headerlink" title="IO/协议"></a>IO/协议</h3><p><code>Tomcat</code>支持的 <code>I/O</code> 模型有（传输层）：</p>
<ul>
<li><code>NIO</code>：非阻塞 <code>I/O</code>，采用 <code>Java NIO</code> 类库实现。</li>
<li><code>NIO2</code>：异步<code>I/O</code>，采用 <code>JDK 7</code> 最新的 <code>NIO2</code> 类库实现。</li>
<li><code>APR</code>：采用 <code>Apache</code>可移植运行库实现，是 <code>C/C++</code> 编写的本地库。</li>
</ul>
<blockquote>
<p> 在 8.0 之前 ，Tomcat 默认采⽤的I/O⽅式为 BIO，之后改为 NIO。 ⽆论 NIO、NIO2 还是 APR， 在性</p>
<p> 能⽅⾯均优于以往的BIO。 如果采⽤APR， 甚⾄可以达到 Apache HTTP Server 的影响性能</p>
</blockquote>
<p><code>Tomcat</code>支持的<code>应用层</code>协议有：</p>
<ul>
<li><code>HTTP/1.1</code>：这是大部分 Web 应用采用的访问协议。</li>
<li><code>AJP</code>：用于和 Web 服务器集成（如 Apache）。以实现对静态资源的优化以及集群部署，当前支持AJP/1.3。</li>
<li><code>HTTP/2</code>：HTTP 2.0 大幅度的提升了 Web 性能。下一代HTTP协议 ， 自8.5以及9.0版本之后支持。</li>
</ul>
<h3 id="内部组件及流程"><a href="#内部组件及流程" class="headerlink" title="内部组件及流程"></a>内部组件及流程</h3><p><img src="http://tencent.fengabner.com/ap-guangzhoutomcat06.png" alt="tomcat06"></p>
<p><font color="red"><strong>EndPoint</strong></font></p>
<p>EndPoint 是 Coyote 通信端点，即通信监听的接⼝，是具体Socket接收和发送处理器，是对传输层的抽象，因此EndPoint⽤来实现TCP/IP协议的。</p>
<p><font color="red"><strong>Processor</strong></font></p>
<p>Processor 是Coyote 协议处理接⼝ ，如果说EndPoint是⽤来实现TCP/IP协议的，那么Processor⽤来实现HTTP协议，Processor接收来⾃EndPoint的Socket，读取字节流解析成Tomcat Request和Response对象，并通过Adapter将其提交到容器处理，Processor是对应⽤层协议的抽象。</p>
<p><font color="red"><strong>ProtocolHandler</strong></font></p>
<p>Coyote 协议接⼝， 通过Endpoint 和 Processor ， 实现针对具体协议的处理能⼒。Tomcat 按照协议和I/O 提供了6个实现类 ： AjpNioProtocol ，AjpAprProtocol， AjpNio2Protocol ， Http11NioProtocol ，Http11Nio2Protocol ，Http11AprProtocol。</p>
<p><font color="red"><strong>Adapter</strong> </font></p>
<p>由于协议不同，客户端发过来的请求信息也不尽相同，Tomcat定义了⾃⼰的Request类来封装这些请求信息。ProtocolHandler接⼝负责解析请求并⽣成Tomcat Request类。但是这个Request对象不是标准的ServletRequest，不能⽤Tomcat Request作为参数来调⽤容器。Tomcat设计者的解决⽅案是引⼊CoyoteAdapter，这是适配器模式的经典运⽤，连接器调⽤CoyoteAdapter的Sevice⽅法，传⼊的是Tomcat Request对象，CoyoteAdapter负责将Tomcat Request转成ServletRequest，再调⽤容器。</p>
<h2 id="http-请求处理"><a href="#http-请求处理" class="headerlink" title="http 请求处理"></a>http 请求处理</h2><p><img src="http://tencent.fengabner.com/ap-guangzhoutomcat07.jpeg" alt="tomcat07"></p>
<p><font color="cornflowerblue">假设 请求为 <a href="http://localhost:8080/test/index.jsp" target="_blank" rel="noopener">http://localhost:8080/test/index.jsp</a> 请求被发送到本机端口8080</font></p>
<ul>
<li>Connector监听到请求，把该请求交给它所在的Service的Engine来处理，并等待Engine的回应</li>
<li>Engine获得请求localhost:8080/test/index.jsp，匹配它所有的虚拟主机Host</li>
<li>Engine匹配到名为localhost的Host(即使匹配不到也把请求交给该Host处理，因为该Host被定义为该Engine的默认主机)</li>
<li>localhost Host获得请求/test/index.jsp，匹配它所拥有的所有Context</li>
<li>Host匹配到路径为/test的Context(如果匹配不到就把该请求交给路径名为””的Context去处理)</li>
<li>path=”/test”的Context获得请求/index.jsp，在它的mapping table中寻找对应的servlet</li>
<li>Context匹配到URL PATTERN为*.jsp的servlet，对应于JspServlet类，构造HttpServletRequest对象和HttpServletResponse对象，作为参数调用JspServlet的doGet或doPost方法</li>
<li>Context把执行完了之后的HttpServletResponse对象返回给Host</li>
<li>Host把HttpServletResponse对象返回给Engine</li>
<li>Engine把HttpServletResponse对象返回给Connector</li>
<li>Connector把HttpServletResponse对象返回给客户browser</li>
</ul>
]]></content>
      <categories>
        <category>tomcat</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>tomcat源码环境搭建</title>
    <url>/2021/04/12/tomcat%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="tomcat-源码环境搭建"><a href="#tomcat-源码环境搭建" class="headerlink" title="tomcat 源码环境搭建"></a>tomcat 源码环境搭建</h1><h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><p><a href="https://tomcat.apache.org/" target="_blank" rel="noopener">下载地址</a></p>
<a id="more"></a>

<p><img src="http://tencent.fengabner.com/ap-guangzhoutomcat08-1617797507419.png" alt="tomcat08"></p>
<h2 id="创建resource目录"><a href="#创建resource目录" class="headerlink" title="创建resource目录"></a>创建resource目录</h2><p><img src="http://tencent.fengabner.com/ap-guangzhoutomcat09.png" alt="tomcat09"></p>
<p><font color="red">将conf 目录和 webapps 目录放到 resource 目录下</font></p>
<h2 id="创建pom-xml"><a href="#创建pom-xml" class="headerlink" title="创建pom.xml"></a>创建pom.xml</h2><p><font color="red">在根目录创建 pom.xml</font></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>apache-tomcat-8.5.50-src<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Tomcat8.5<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定源⽬录--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>Tomcat8.5<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>java<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--引⼊编译插件--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--tomcat 依赖的基础包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.easymock<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easymock<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ant<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ant<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>wsdl4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>wsdl4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.xml<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxrpc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jdt.core.compiler<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ecj<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.xml.soap<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.xml.soap-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="导入IDEA"><a href="#导入IDEA" class="headerlink" title="导入IDEA"></a>导入IDEA</h2><p>使用idea打开项目，配置启动类 Bootstrap </p>
<p><img src="http://tencent.fengabner.com/ap-guangzhoutomcat11.png" alt="tomcat11"></p>
<p>配置VM启动参数</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">-Dcatalina.home=D:/develop/github/apache-tomcat-8.5.64/resource</span><br><span class="line">-Dcatalina.base=D:/develop/github/apache-tomcat-8.5.64/resource</span><br><span class="line">-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager</span><br><span class="line">-Djava.util.logging.config.file=D:/develop/github/apache-tomcat-8.5.64/resource/conf/logging.properties</span><br></pre></td></tr></table></figure>

<h2 id="错误解决"><a href="#错误解决" class="headerlink" title="错误解决"></a>错误解决</h2><h3 id="HTTP-状态500"><a href="#HTTP-状态500" class="headerlink" title="HTTP 状态500"></a>HTTP 状态500</h3><p><img src="http://tencent.fengabner.com/ap-guangzhoutomcat10.png" alt="tomcat10"></p>
<p>解决方案：</p>
<p>在org.apache.catalina.startup.ContextConfig#configureStart方法中加入以下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">context.addServletContainerInitializer(<span class="keyword">new</span> JasperInitializer(), <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<h3 id="程序包问题"><a href="#程序包问题" class="headerlink" title="程序包问题"></a>程序包问题</h3><p>如报错： java: 程序包 sun.rmi.registry 不可见</p>
<p>解决方案：按照idea提示操作即可</p>
]]></content>
      <categories>
        <category>tomcat</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>Eureka介绍与搭建</title>
    <url>/2021/04/14/Eureka%E4%BB%8B%E7%BB%8D%E4%B8%8E%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Eureka 是 Netflix 开源的一款注册中心，它提供服务注册与服务发现功能。</p>
<p>官方架构图</p>
<a id="more"></a>

<p><img src="http://tencent.fengabner.com/ap-guangzhoueureka6.png" alt="eureka6"></p>
<h1 id="单体服务搭建"><a href="#单体服务搭建" class="headerlink" title="单体服务搭建"></a>单体服务搭建</h1><p>环境 idea+java11+maven</p>
<p>建立父工程 <font color="cornflowerblue">demo-parent</font></p>
<p>pom.xml文件如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.fengabner<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--父工程打包方式为pom--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--spring boot 父启动器依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">lombok.version</span>&gt;</span>1.18.4<span class="tag">&lt;/<span class="name">lombok.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jaxb-core.version</span>&gt;</span>2.2.11<span class="tag">&lt;/<span class="name">jaxb-core.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jaxb-impl.version</span>&gt;</span>2.2.11<span class="tag">&lt;/<span class="name">jaxb-impl.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jaxb-runtime.version</span>&gt;</span>2.2.10-b140310.1920<span class="tag">&lt;/<span class="name">jaxb-runtime.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation.version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">activation.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--spring cloud依赖管理，引入了Spring Cloud的版本--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>Greenwich.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--web依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日志依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--测试依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--lombok工具--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;lombok.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Actuator可以帮助你监控和管理Spring Boot应用--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--热部署--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--引⼊Jaxb，开始--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jaxb-core.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jaxb-impl.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.glassfish.jaxb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-runtime<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jaxb-runtime.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.activation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;activation.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--引⼊Jaxb，结束--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--编译插件--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--打包插件--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>基于Maven构建SpringBoot⼯程，在SpringBoot⼯程之上搭建EurekaServer服务  </p>
<p>子工程 <font color="red"><strong>demo-eureka-server1</strong></font></p>
<p>pom.xml如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.fengabner<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fengabner<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo-eureka-server1<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>demo-eureka-server1<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><font color="red"><strong>注意：在⽗⼯程的pom⽂件中⼿动引⼊jaxb的jar，因为Jdk9之后默认没有加载该模块，<br>EurekaServer使⽤到，所以需要⼿动导⼊，否则EurekaServer服务⽆法启动</strong>  </font></p>
<p>查看父工程中以下引入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引⼊Jaxb，开始--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jaxb-core.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jaxb-impl.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.glassfish.jaxb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-runtime<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jaxb-runtime.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.activation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;activation.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引⼊Jaxb，结束--&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoEurekaServer1Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoEurekaServer1Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">18061</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment"># 应⽤名称，会在Eureka中作为服务的id标识</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#由于该应用为注册中心,所以设置为false,代表不向注册中心注册自己</span></span><br><span class="line">    <span class="attr">registerWithEureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">#由于注册中心的职责就是维护服务实例,它并不需要去检索服务,所以也设置为false</span></span><br><span class="line">    <span class="attr">fetchRegistry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">freemarker:</span></span><br><span class="line">    <span class="attr">prefer-file-system-access:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>启动后，访问 ip:port 如 <a href="http://localhost:18601" target="_blank" rel="noopener">http://localhost:18601</a></p>
<p><img src="http://tencent.fengabner.com/ap-guangzhoueureka1.png" alt="eureka1"></p>
<p>说明：</p>
<p><img src="http://tencent.fengabner.com/ap-guangzhoueureka2.png" alt="eureka2"></p>
<h1 id="集群服务搭建"><a href="#集群服务搭建" class="headerlink" title="集群服务搭建"></a>集群服务搭建</h1><p>在上面的基础上再次新建一个子工程<font color="red"> <strong>demo-eureka-server2</strong></font>，配置与<font color="red"> <strong>demo-eureka-server1</strong></font> 一样，设置一个不同的端口</p>
<p>使用本机环境测试很难模拟多主机的情况  ，需要修改host，将来正式环境使用真实的就行。</p>
<p>修改 hosts</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">127.0.0.1 eurekaServer1</span><br><span class="line">127.0.0.1 eurekaServer2</span><br></pre></td></tr></table></figure>

<p>修改 <font color="red"> <strong>demo-eureka-server1</strong></font> 配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">18061</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment"># 应⽤名称，会在Eureka中作为服务的id标识</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eurekaServer1</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#集群模式下，需向注册中心注册自己 设置为true</span></span><br><span class="line">    <span class="attr">registerWithEureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#集群模式下，需要去检索服务,设置为true</span></span><br><span class="line">    <span class="attr">fetchRegistry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eurekaServer2:18062/eureka</span></span><br><span class="line">  <span class="attr">dashboard:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">freemarker:</span></span><br><span class="line">    <span class="attr">prefer-file-system-access:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">demo-eureka-server1</span></span><br></pre></td></tr></table></figure>

<p>修改 <font color="red"> <strong>demo-eureka-server2</strong></font> 配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">18062</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment"># 应⽤名称，会在Eureka中作为服务的id标识</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eurekaServer2</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#集群模式下，需向注册中心注册自己 设置为true</span></span><br><span class="line">    <span class="attr">registerWithEureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#集群模式下，需要去检索服务,设置为true</span></span><br><span class="line">    <span class="attr">fetchRegistry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eurekaServer1:18061/eureka</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">freemarker:</span></span><br><span class="line">    <span class="attr">prefer-file-system-access:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">demo-eureka-server2</span></span><br></pre></td></tr></table></figure>

<p>启动两个服务，查看如下</p>
<p><img src="http://tencent.fengabner.com/ap-guangzhoueureka3.png" alt="image-20210413142756642"></p>
<p><img src="http://tencent.fengabner.com/ap-guangzhoueureka4.png" alt="image-20210413142841378"></p>
]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
      <tags>
        <tag>eureka</tag>
        <tag>springcloud</tag>
      </tags>
  </entry>
</search>
